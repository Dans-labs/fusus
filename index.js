URLS=[
"fusus/index.html",
"fusus/clean.html",
"fusus/lib.html",
"fusus/layout.html",
"fusus/lakhnawi.html",
"fusus/char.html",
"fusus/page.html",
"fusus/pdf.html",
"fusus/about/index.html",
"fusus/about/engineer.html",
"fusus/about/run.html",
"fusus/about/methods.html",
"fusus/about/model.html",
"fusus/about/work.html",
"fusus/about/sources.html",
"fusus/about/tweak.html",
"fusus/about/explore.html",
"fusus/about/install.html",
"fusus/about/cheatsheet.html",
"fusus/about/howto.html",
"fusus/lines.html",
"fusus/ocr.html",
"fusus/parameters.html",
"fusus/book.html",
"fusus/convert/index.html",
"fusus/convert/tfFromTsv.html",
"fusus/convert/tsvFromCommentary.html",
"fusus/convert/tsvFromAffifi.html",
"fusus/convert/tsvFromLakhnawi.html",
"fusus/convert/tsvFromBook.html"
];
INDEX=[
{
"ref":"fusus",
"url":0,
"doc":"![logo](images/fusus-small.png)  Fusus Pipeline A workflow from Arabic page images to textual data.  Straight to  .  Install ( fusus.about.install )  HowTo ( fusus.about.howto )  Sources ( fusus.about.sources )  Authors  [Cornelis van Lit](https: digitalorientalist.com/about-cornelis-van-lit/)  [Dirk Roorda](https: www.annotation.nl)"
},
{
"ref":"fusus.clean",
"url":1,
"doc":""
},
{
"ref":"fusus.clean.cluster",
"url":1,
"doc":"Cluster points that are in a source. When searching images for image templates, we get a match image: for each point in the image a measure of how good the match is at that point. Typically, if a point has a high match value, surrounding points also have good match values. We want to cluster such points, so that we can identify a match with exactly one cluster. Parameters      points: iterable Points where the image template matches the source image good enough match: image as np array The match image Returns    - list The list of clusters, where each cluster is represented as a pair of point and the strength of the match in that point. This point is the point in the cluster with the highest match value.",
"func":1
},
{
"ref":"fusus.clean.measure",
"url":1,
"doc":"Measure the amount of ink that crosses the border of a certain region. It is used to reject certain matches of image templates, where templates contain strokes of ink. If a match is such that the stroke of ink connects with the ink in the environment, the match is not a true example of the stroke and will be rejected.  ! note \"Where to look for ink\" We look for ink in the image itself, the ink in the search template is not relevant. Parameters      borderInside: image as np array The part of the image bordering inside an area where the search template matches borderOutside: image as np array The part of the image bordering outside an area where the search template matches Returns    - float The ratio between the size of the ink connections across the border and the total size of the border.",
"func":1
},
{
"ref":"fusus.clean.connected",
"url":1,
"doc":"Determine how much ink borders on a given rectangle. Parameters      markH: integer height of the rectangle markW: integer width of the rectangle bw: integer width of the border around the rectangle that will be used to detect connections threshold: the value above which a connection is detected img: np array the source image hitPoint: (int, int) Y and X coordinate of top left corner of the rectangle in the image sides: string, optional  None If  None , computes connections on all sides. Otherwise it should be a string consisting of at most these characters:  l (left),  r (right),  t (top),  b (bottom). Only these sides will be computed.",
"func":1
},
{
"ref":"fusus.clean.reborder",
"url":1,
"doc":"Add a border around a grayscale image, optionally remove white margins first. The border will add to the size of the image. Parameters      gray: np array A grayscale image. bw: int Width of the new border. color: int Color of the new border (grayscale). crop: boolean, optional  False If  True , the image will be cropped first such as to remove all surrounding white margins.",
"func":1
},
{
"ref":"fusus.clean.addBox",
"url":1,
"doc":"Add a box around a mark that is to be cleaned. When we display the marks that will be wiped from the image, we do so by putting colored boxes around them. This function adds one such box. Parameters C: object The configuration object of the book engine. img: image as np array the image to operate on left, top, right, bottom: int specification of the rectangle of the box kept: boolean Whether the mark is to be kept. Kept marks and wiped marks will get different colors. band: string The name of the band in which the mark is searched for. It will be displayed near the box. seq: integer The number of the mark. connDegree: integer The degree of ink connection for this mark occurrence. It will be displayed near the box. Returns    - None The source image receives a modification.",
"func":1
},
{
"ref":"fusus.lib",
"url":2,
"doc":""
},
{
"ref":"fusus.lib.pprint",
"url":2,
"doc":"",
"func":1
},
{
"ref":"fusus.lib.EXTENSIONS",
"url":2,
"doc":"Supported image file extensions."
},
{
"ref":"fusus.lib.tempFile",
"url":2,
"doc":"Get a temporary file.",
"func":1
},
{
"ref":"fusus.lib.imgElem",
"url":2,
"doc":"Produce an image with its data packaged into a HTML  element.",
"func":1
},
{
"ref":"fusus.lib.PILFromArray",
"url":2,
"doc":"",
"func":1
},
{
"ref":"fusus.lib.arrayFromPIL",
"url":2,
"doc":"",
"func":1
},
{
"ref":"fusus.lib.showImage",
"url":2,
"doc":"Show one or more images.",
"func":1
},
{
"ref":"fusus.lib.writeImage",
"url":2,
"doc":"Write an image to disk",
"func":1
},
{
"ref":"fusus.lib.overlay",
"url":2,
"doc":"Colors a region of an image with care. A selected region of an image can be given a uniform color, where only pixels are changed that have an exact given color. In this way you can replace all the white with gray, for example, without wiping out existing non-white pixels. Parameters      img: np array The image to be overlain with a new color (left, top, right, bottom): (int, int, int, int) The region in the image to be colored srcColor: RGB color The color of the pixels that may be replaced. dstColor: The new color of the replaced pixels.",
"func":1
},
{
"ref":"fusus.lib.splitext",
"url":2,
"doc":"Splits a file name into its main part and its extension. Parameters      f: string The file name withDot: boolean, optional  False If True, the  . in the extension is considered part of the extension, else the dot is stripped from it. Returns    - tuple The main part and the extension",
"func":1
},
{
"ref":"fusus.lib.imageFileList",
"url":2,
"doc":"Gets a sorted list of image files from a directory. Only files having an image extension (defined in  EXTENSIONS ) are listed. Parameters      imDir: string Path to the image directory Returns    - list Alphabetically sorted list of file names (without directory, with extension)",
"func":1
},
{
"ref":"fusus.lib.imageFileListSub",
"url":2,
"doc":"Gets sorted lisst of image files from the subdirectories of a directory. Only files having an image extension (defined in  EXTENSIONS ) are listed. Parameters      imDir: string Path to the image directory Returns    - dict Keyed by subdirectory names, valued by alphabetically sorted list of file names (without directory, with extension)",
"func":1
},
{
"ref":"fusus.lib.pagesRep",
"url":2,
"doc":"Represents a set of pages as a string in a compact way or as a list. Parameters      source: list A list of file names, without directory, with extension asList: boolean, optional  False Whether to return the result as a list of integers or as a compact string. Returns    - list or string Depending on  asList a list of page numbers (integers) or a string mentioning the page numbers, using intervals where possible.",
"func":1
},
{
"ref":"fusus.lib.select",
"url":2,
"doc":"Choose items from a bunch of integers. Parameters      source: iterable of int The items to choose from selection: iterable of int or string or  None If None, selects all items, otherwise specifies what numbers to select. If a number is in the selection, but not in the source, it will not be selected. The selection can be an integer or a compact string that specifies integers, using ranges and commas. Returns    - list Sorted list of selected items",
"func":1
},
{
"ref":"fusus.lib.removeSkewStripes",
"url":2,
"doc":"Remove black triangles resulting from unskewing images. When an image has been unskewed, sharp triangle-shape strokes in the corners may have been introduced. This function removes them by coloring all image borders with white. The width of these borders is calculated as a fraction of the width and height of the image. The fraction ultimately comes from the parameter  skewBorderFraction in  fusus.parameters.SETTINGS . Parameters      img: image as np array the image to operate on skewBorder: int the width of the border that is whitened skewColor: color the exact white color with which we color the borders. Returns    - None The source image receives a modification.",
"func":1
},
{
"ref":"fusus.lib.parseStages",
"url":2,
"doc":"Parses a string that specifies stages. Stages are steps in the image processing. Each stage has an intermediate processing result. Parameters      stage: string or None or iterable If None: it means all stages. If a string: the name of a stage. If an iterable: the items must be names of stages. allStages: tuple Names of all stages. sortedStages: Sorted list of all stages. error: function Method to write error messages. Returns    - tuple The stages as parsed.",
"func":1
},
{
"ref":"fusus.lib.parseBands",
"url":2,
"doc":"Parses a string that specifies bands. Bands are horizontal rectangles defined with respect to lines. They correspond with regions of interest where we try to find specific marks, such as commas and accents. Parameters      band: string or None or iterable If None: it means all bands. If a string: the name of a band. If an iterable: the items must be names of bands. allBands: tuple Names of all bands. error: function Method to write error messages. Returns    - tuple The bands as parsed.",
"func":1
},
{
"ref":"fusus.lib.parseMarks",
"url":2,
"doc":"Parses a string that specifies Marks. Marks are strokes that we need to find on the page in order to remove them. They are organized in bands: the regions of interest with respect to the lines where we expect them to occur. Parameters      mark: string or None or iterable If None: it means all marks. If a string: the name of a mark. If an iterable: the items must be names of marks. allMarks: tuple Names of all marks. error: function Method to write error messages. Returns    - tuple The marks as parsed.",
"func":1
},
{
"ref":"fusus.lib.findRuns",
"url":2,
"doc":"Find runs of consecutive items in an array. Credits: [Alistair Miles](https: gist.github.com/alimanfoo/c5977e87111abe8127453b21204c1065)",
"func":1
},
{
"ref":"fusus.lib.applyBandOffset",
"url":2,
"doc":"Produce bands from a list of lines. Bands are defined relative to lines by means of offsets of the top and bottom heights of the lines. Bands may also be interlinear: defined between the bottom of one line and the top of the next line. Parameters      C: object Configuration settings height: The height of the page or block bandName: string The name of the bands lines: tuple The lines relative to which the bands have to be determined. Lines are given as a tuple of tuples of top and bottom heights. inter: boolean, optional  False Whether the bands are relative the lines, or relative the interlinear spaces. Returns    - tuple For each line the band named bandName specified by top and bottom heights.",
"func":1
},
{
"ref":"fusus.lib.getMargins",
"url":2,
"doc":"Get margins from a histogram. The margins of a histogram are the coordinates where the histogram reaches a threshold for the first time and for the last time. We deliver the pairs (0, xFirst) and (xLast, maxWidth) if there are points above the threshold, and (0, maxW) otherwise. Parameters      hist: [int] Source array of pixel values width: int Maximum index of the source array threshold: int Value below which pixels count as zero",
"func":1
},
{
"ref":"fusus.lib.pureAverage",
"url":2,
"doc":"Get the average of a list of values after removing the outliers. It is used for calcaluting lineheights from a sequence of distances between histogram peaks. In practice, some peaks are missing due to short line lengths, and that causes some abnormal peak distances which we want to remove. Parameters      data: np array The list of values whose average we compute. supplied: integer Value to return if there is no data.",
"func":1
},
{
"ref":"fusus.layout",
"url":3,
"doc":""
},
{
"ref":"fusus.layout.addBlockName",
"url":3,
"doc":"Adds the name of a block of the page near the block. The function  fusus.page.Page.doLayout divides the page into blocks. This function puts the name of each block on the image, positioned suitably w.r.t. the block. Parameters      img: image as np array the image to operate on top, left, right: integer Where the top, left, right edges of the image are. marginX: integer Where we set the left margin letterColor: color The color of the letters stripe: integer The stripe number. Stripes are horizontal page-wide regions corresponding to  vertical column dividers. kind: string Whether the block spans the whole page width (   ), is in the left column (\"l\") or in the right column (\"r\"). size: float The font-size of the letters. Returns    - None The source image receives a modification.",
"func":1
},
{
"ref":"fusus.layout.addHStroke",
"url":3,
"doc":"Marks a detected horizontal stroke on an image. The layout algorithm detects horizontal strokes. For feedback to the user, we draw a frame around the detected strokes and give them a name. Parameters      img: image as np array the image to operate on isTop: boolean whether the stroke separates the top header from the rest of the page. i: integer The number of the stroke column: string {\"l\", \"r\",  } The column in which the stroke is found thickness: integer The thickness of the stroke as found on the image. top, left, right: integer Where the top, left, right edges of the image are. letterColor: color The color of the letters size: float The font-size of the letters. Returns    - None The source image receives a modification.",
"func":1
},
{
"ref":"fusus.layout.getStretches",
"url":3,
"doc":"Gets significant horizontal or vertical strokes. Significant strokes are those that are not part of letters, but ones that are used as separators, e.g. of footnotes and columns. We single out 1-pixel wide lines longer than a small threshold in the appropriate direction, and blacken the rest. Then we blur in the perpendicular direction. Now we single out longer 1-pixel wide lines and cluster in the perpendicular direction. Clusters are line segments with nearly the same constant coordinate. If we do horizontal lines, clusters are pairs of x coordinates for one y coordinate. If we do vertical lines, clusters are pairs of y coordinates for one x coordinate. We return the clusters, i.e. a dict keyed by the fixed coordinate and valued by the pair of segment coordinates. Parameters      C: object The configuration object of the book engine. info: function To write messages to the console stages: dict Intermediate cv2 images, keyed by stage name pageSize: int The width or height in pixels of a complete page. Note that the image we work with, might be a fraction of a page horizontal: boolean Whether we do horizontal of vertical lines. batch: boolean Whether we run in batch mode. Returns    - dict Per fixed coordinate the list of line segments on that coordinate. A line segment is specified by its begin and end values and the thickness of the cluster it is in.",
"func":1
},
{
"ref":"fusus.layout.getStripes",
"url":3,
"doc":"Infer horizontal stripes from a set of vertical bars. A vertical bar defines a stripe on the page, i.e. a horizontal band that contains that bar. Between the vertical bars there are also stripes, they are undivided stripes. We assume the vertical bars split the page in two portions, and not more, and that they occur more or less in the middle of the page. If many vertical bars have been detected, we sort them by y1 ascending and then y2 descending and then by x. We filter the bars: if the last bar reached to y = height, we only consider bars that start lower than height.  ! note \"Fine tuning needed later on\" The vertical strokes give a rough estimate: it is possible that they start and end in the middle of the lines beside them. We will need histograms for the fine tuning. Parameters      stages: dict We need access to the normalized stage to get the page size. stretchesV: dict Vertical line segments per x-coordinate, as delivered by  getStretches . Returns    - list A list of stripes, specified as (x, y1, y2) values, where the y-coordinates y1 and y2 specify the vertical extent of the stripe, and x is the x coordinate of the dividing vertical stroke if there is one and  None otherwise.",
"func":1
},
{
"ref":"fusus.layout.getBlocks",
"url":3,
"doc":"Fine-tune stripes into blocks. We enlarge the stripes vertically by roughly a line height and call  adjustVertical to get precise vertical demarcations for the blocks at both sides of the stripe if there is one or else for the undivided stripe. The idea is: If a stripe has a vertical bar, we slightly extend the boxes left and right so that the top and bottom lines next to the bar are completely included. If a stripe has no vertical bar, we shrink the box so that partial top and bottom lines are delegated to the boxes above and below. We only shrink if the box is close to the boxes above or below. We do not grow boxes across significant horizontal strokes. We write the box layout unto the  layout layer. Parameters      C: object Configuration settings stages: dict We need access to several intermediate results. pageH: int The height of a full page in pixels (the image might be a fraction of a page) stripes: list The preliminary stripe division of the page, as delivered by  getStripes . stretchesH: list The horizontal stretches across which we do not shrink of enlarge batch: boolean Whether we run in batch mode. Returns    - dict Blocks keyed by stripe number and column specification (one of    ,  \"l\" ,  \"r\" ). The values form dicts themselves, with in particular the bounding box information under key  box specified as four numbers: left, top, right, bottom. The dict is ordered.",
"func":1
},
{
"ref":"fusus.layout.applyHRules",
"url":3,
"doc":"Trims regions above horizontal top lines and below bottom lines. Inspect the horizontal strokes and specifiy which ones are top separators and which ones are bottom separators. First we map each horizontal stretch to one of the page stripes. If a stretch occurs between stripes, we map it to the stripe above. A horizontal stroke is a top separator if  it is mapped to the first stripe  and  it is situated in the top fragment of the page. We mark the discarded material on the layout page by overlaying it with gray. Parameters      C: object Configuration settings stages: dict We need access to several intermediate results. stretchesH: dict Horizontal line segments per y-coordinate, as delivered by  getStretches . stripes: list The preliminary stripe division of the page, as delivered by  getStripes . blocks: dict The blocks as delivered by  getBlocks . boxed: boolean Whether we run in boxed mode (generate boxes around wiped marks). Returns    - None The blocks dict will be updated: each block value gets a new key  inner with the bounding box info after stripping the top and bottom material.",
"func":1
},
{
"ref":"fusus.layout.grayInterBlocks",
"url":3,
"doc":"Overlay the space between blocks with gray. Remove also the empty blocks from the block list. Parameters      C: object Configuration settings stages: dict We need access to several intermediate results. blocks: dict The blocks as delivered by  getBlocks . The blocks dict will be updated: empty blocks will be deleted from it. with the band data. Returns    - None.",
"func":1
},
{
"ref":"fusus.layout.adjustVertical",
"url":3,
"doc":"Adjust the height of blocks. When we determine the vertical sizes of blocks from the vertical column separators on the page, we may find that these separators are too short. We remedy this by finding the line divisision of the ink left and right from the dividing line, and enlarging the blocks left and right so that they contain complete lines. Parameters      C: object Configuration settings info: function To write messages to the console blurred: image as np array The input image. It must be the  blurred stage of the source image, which is blurred and inverted. pageH: int size of a full page in pixels left, right: int The left and right edges of the block yMin: integer the initial top edge of the block yMinLee: integer the top edge of the block when the leeway is applied yMax: integer the initial bottom edge of the block yMaxLee: integer the bottom edge of the block when the leeway is applied preferExtend: boolean Whether we want to increase or rather decrease the vertical size of the block. Blocks next to dividing lines are meant to be increased, blocks that span the whole page width are meant to be decreased. Returns    - tuple The corrected top and bottom heights of the block.",
"func":1
},
{
"ref":"fusus.lakhnawi",
"url":4,
"doc":""
},
{
"ref":"fusus.lakhnawi.preHtml",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.getToc",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.tweakSpace",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.ptRepD",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.ptRep",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.getDictFromDef",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.parseNums",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi",
"url":4,
"doc":""
},
{
"ref":"fusus.lakhnawi.Lakhnawi.close",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.setStyle",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.getCharConfig",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.privateInfo",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.setupRules",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.getCharInfo",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showChar",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.plainChar",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showString",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.plainString",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showReplacements",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.parsePageNums",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.drawPages",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.getPages",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.getPageRaw",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.getPageObj",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.plainPages",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.tsvPages",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.htmlPages",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showLines",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showWords",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showUsedChars",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showColumns",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.showSpacing",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.collectPage",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.isPageNum",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.trimLine",
"url":4,
"doc":"Map character sequences to other sequences. Two tasks: 1. Map private use characters to well-known unicode characters 2. Insert space characters where the next character is separated from the previous one. Complications: Diacritical characters are mostly contained in a very wide box that overlaps with the boxes of the other characters. So the diacritical boxes must not be taken into account. Private use characters often com in sequences, so a sequence of characters must be transformed to another sequence. We do the tramsformation before the space insertion, because otherwise we might insert the space at the wrong point. When we transform characters we need to retain the box information, because we still have to insert the space. That's why we have as input a list of character records, where each record is itself a list with box information, orginal character, modified characters and space information. When we transform characters, we modify character records in place. We do not add or remove character records. The last member of a character record is the modified sequence. This can be zero, one, or multiple characters. The second last member is the original character. Initially, the the last and second last member of each record are equal. We call these members the original character and the result string. Space will be appended at the last member of the appropriate character records. The transformations are given as a set of rules. A rule consists of a sequence of characters to match and a sequence of characters to replace the match with. We call them the match sequence and the replacement sequence of the rule. For each character in the input list we check which rules have a match sequence that start with this character. Of these rules, we start with the one with the longest match sequence. We then check, by looking ahead, whether the whole match sequence matches the input. For the purposes of matching, we look into the result strings of the character, not to the original characters. This will prevent some rules to be applied after an earlier rule has been applied. This is intentional, and results in a more simple rule set. If there is a match, we walk through all the characters in the input for the length of the match sequence of the rule. For each input character record, we set its replacement string to the corresponding member of the replacement sequence of the rule. If the replacement sequence has run out, we replace with the empty string. If after this process the replacement sequence has not been exhausted, we join the remaining characters in the replacement string and append it after the replacement string of the last input character that we have visited. After succesful application of a rule, we do not apply other rules that would have been applicable at this point. Instead, we move our starting point to the next character record in the sequence and repeat the matching process. It might be that a character is replaced multiple times, for example when it is reached by a rule while looking ahead 3 places, and then later by a different rule looking ahead two places. However, once a character matches the first member of the match sequence of a rule, and the rule matches and is applied, that character will not be changed anymore by any other rule. The match sequence may contain the character  d , which is a placeholder for a diacritic sign. It will match any diacritic. The replacement sequence of such a rule may or may not contain a  d . It is an error if the replacement seqience of a rule contains a  d while its match sequence does not. It is also an error of there are multiple  d s in a match sequence of a replacement sequence. If so, the working of this rule is effectively two rules: Suppose the rule is x d y => r d s where x, y, r, s are sequences of arbitrary length. If the rule matches the input, then first the rule x => r will be applied at the current position. Then we shift temporarily to the position right after where the d has matched, and apply the rule y => s Then we shift back to the orginal position plus one, and continue applying rules.",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.plainLine",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.tsvHeadLine",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.tsvLine",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.Lakhnawi.htmlLine",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.lakhnawi.keyCharV",
"url":4,
"doc":"The vertical position of the middle of a character. Used to sort the characters of a page in the vertical direction.",
"func":1
},
{
"ref":"fusus.lakhnawi.keyCharH",
"url":4,
"doc":"Sort key to sort the characters of a line horizontally. Basically, characters whose right edge are closer to the right edge of the page come before characters whose right edges are further left. So we could sort on minus the x coordinate of the right edge. However, there are complications. Sometimes characters have the same right edge. Diacritics usually start right after the letter they are on together with the next letter. So they should come before that next letter. In those cases we take the width into account. Private use diacritics usually have a big width, they are wider than letters. So if we sort wider characters before narrower characters, we get that right. However, normal unicode diacritics have a typical width of zero, and also these should come before the next letter. We can solve that by sorting by a key defined as 1 divided by the widthss if the width is nonzero, and 0 if the the width is zero. Then zero width characters come first, then wide characters, then narrow characters. One extra complication: the widths are not integers but fractions. Sometimes a the diacritic and the next letter have an almost equal right edge, but not quite equal, and the wrong one comes first. We can solve that by rounding.",
"func":1
},
{
"ref":"fusus.lakhnawi.clusterVert",
"url":4,
"doc":"",
"func":1
},
{
"ref":"fusus.char",
"url":5,
"doc":""
},
{
"ref":"fusus.char.uName",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.getSetFromRanges",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.getSetFromDef",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.getMapFromPairs",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.normalizeC",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.normalizeD",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.isAlefFinal",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.isMeemOrYeh",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.isWaw",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.isArDigit",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.isEuDigit",
"url":5,
"doc":"",
"func":1
},
{
"ref":"fusus.char.UChar",
"url":5,
"doc":""
},
{
"ref":"fusus.page",
"url":6,
"doc":"Single page processing."
},
{
"ref":"fusus.page.Page",
"url":6,
"doc":"All processing steps for a single page. Parameters      engine: object The  fusus.book.Book object f: string The file name of the scanned page with extension, without directory sizeW: float, default 1 If the image is a fraction of a page, this is the fraction of the width sizeH: float, default 1 If the image is a fraction of a page, this is the fraction of the size minimal: boolean, optional  False If true, do not read image files, just initialize data structures batch: boolean, optional  False Whether to run in batch mode. In batch mode everything is geared to the final output. Less intermediate results are computed and stored. Less feedback happens on the console. boxed: boolean, optional  True If in batch mode, produce also images that display the cleaned marks in boxes."
},
{
"ref":"fusus.page.Page.show",
"url":6,
"doc":"Displays processing stages of an page. See  fusus.parameters.STAGES . Parameters      stage: string | iterable, optional  None If no stage is passed, all stages are shown as thumbnails. Otherwise, the indicated stages are shown. If a string, it may be a comma-separated list of stage names. Otherwise it is an iterable of stage names. band: string | iterable, optional  None If no band is passed, no bands are indicated. Otherwise, the indicated bands are shown. If a string, it may be a comma-separated list of band names. Otherwise it is an iterable of band names. mark: string | iterable, optional  None If  None is passed, no marks are shown. If    is passed, all marks on the selected bands are shown. Otherwise, the indicated mark boxes are shown, irrespective of their bands: If given as a string, it may be a comma-separated list of mark names. Otherwise it is an iterable of mark names. This information will be taken from the result of the  markData stage. display: dict, optional A set of display parameters, such as  width ,  height (anything accepted by  IPython.display.Image ). Notes   - The mark option works for the \"boxed\" stage: All marks not specified in the mark parameter will not be shown. But this option also works for all other image stages: the marks will be displayed on a fresh copy of that stage. When used for a grayscale stage, the color of the mark boxes is lost.",
"func":1
},
{
"ref":"fusus.page.Page.stagePath",
"url":6,
"doc":"",
"func":1
},
{
"ref":"fusus.page.Page.read",
"url":6,
"doc":"Reads processing data for selected stages from disk Parameters      stage: string | iterable, optional  None If no stage is passed, all stages will be read, if corresponding files are present. Otherwise, the indicated stages are read.",
"func":1
},
{
"ref":"fusus.page.Page.write",
"url":6,
"doc":"Writes processing stages of an page to disk. Parameters      stage: string | iterable, optional  None If no stage is passed, all stages are shown as thumbnails. Otherwise, the indicated stages are shown. If a string, it may be a comma-separated list of stage names. Otherwise it is an iterable of stage names. perBlock: boolean, optional  False If True, the stage output will be split into blocks and written to disk separately. The stripe and column of a block are appended to the file name. Returns    - None The stages are written into the  inter or  clean subdirectory, with the name of the stage appended to the file name. If  clean , the name of the stage is omitted.",
"func":1
},
{
"ref":"fusus.page.Page.doNormalize",
"url":6,
"doc":"Normalizes a page. Previously needed to unskew pages. But now we assume pages are already skewed. Skewing turned out to be risky: when pages are filled in unusual ways, we got unexpected and unwanted rotations. So we don't do that anymore. If the input page images have skew artefacts (black sharp triangles in the corners) as a result of previous skewing these will be removed. Normalization produces the stages:   gray : grayscale version of  orig   blurred : inverted, black-white, blurred without skew artefacts, needed for histograms later on;   normalized :  gray without skew artefacts;   normalizedC :  orig without skew artefacts.",
"func":1
},
{
"ref":"fusus.page.Page.doLayout",
"url":6,
"doc":"Divide the page into stripes and the stripes into columns. We detect vertical strokes as columns separators and horizontal strokes as separators to split off top and bottom material. A page may or may not be partially divided into columns. Where there is a vertical stroke, we define a stripe: the horizontal band that contains the vertical stroke tightly and extends to the full with of the page. Between the stripes corresponding to column separators we have stripes that are not split into columns. The stripes will be numbered from top to bottom, starting at 1. If a stripe is not split, it defines a roi (region of interest) with label  (i,  ) . If it is split, it defines blocks with labels  (i, 'r') and  (i, 'l') . Every horizontal stripe will be examined. We have to determine whether it is a top separator or a bottom separator. As a rule of thumb: horizontal stripes in the top stripe are top-separators, all other horizontal stripes are bottom separators. If there are multiple horizontal strokes in a roi, the most aggressive one will be taken, i.e. the one that causes the most matarial to be discarded. All further operations will take place on these blocks (and not on the page as a whole). The result of this stage is, besides the blocks, an image of the page with the blocks marked and labelled.",
"func":1
},
{
"ref":"fusus.page.Page.cleaning",
"url":6,
"doc":"Remove marks from the page. The blocks of the page are cleaned of marks. New stages of the page are added:   clean all targeted marks removed   cleanh all targeted marks highlighted in light gray   boxed all targeted marks boxed in light gray   markData information about each detected mark. Parameters      mark: iterable of tuples (band, mark, [params]), optional  None If  None , all marks that are presented in the book directory are used. Otherwise, a series of marks is specified together with the band where this mark is searched in. Optionally you can also put parameters in the tuple: the accuracy, connectBorder and connectRatio. block: (integer, string), optional  None Block identifier. If specified, only this block will be cleaned. If absent, cleans all blocks. line: integer, optional  None Line number specifying the line numbers to clean. In all specified blocks, only the line with this number will be cleaned. If absent, cleans all lines in the specified blocks. showKept: boolean, optional  False Whether to show the mark candidates that are kept. If False, kept marks do not show up as green boxes, and they do not contribute to the markData layer.",
"func":1
},
{
"ref":"fusus.page.Page.ocring",
"url":6,
"doc":"Calls the OCR engine for a page.",
"func":1
},
{
"ref":"fusus.page.Page.proofing",
"url":6,
"doc":"Produces proofing images",
"func":1
},
{
"ref":"fusus.pdf",
"url":7,
"doc":""
},
{
"ref":"fusus.pdf.pdf2png",
"url":7,
"doc":"Extract all images in a PDF to an output directory.",
"func":1
},
{
"ref":"fusus.about",
"url":8,
"doc":" Documents Higher level documentation."
},
{
"ref":"fusus.about.engineer",
"url":9,
"doc":""
},
{
"ref":"fusus.about.run",
"url":10,
"doc":" Run The pipeline can read Arabic books in the form of page images, and returns structured data in the form of tab separated files.  Books As far as the pipeline is concerned, the input of a book is a directory of page images. More precisely, it is a directory in which there is a subdirectory  in having the page images. The books of the Fusus project are in the directory  ur of this repo. There you find subdirectories corresponding to   Affifi The Fusus Al Hikam in the Affifi edition.   Lakhnawi The Fusus Al Hikam in the Lakhnawi edition. The source is a textual PDF, not in the online repo, from which structured data is derived by means of a specific workflow, not the  pipeline .   commentary Xxx Commentary books When the pipeline runs, it produces additional directories containing intermediate results and output. For details, see  fusus.book .  Book in batch You can run the pipeline on the known works inside the  ur directory in this repo or on books that you provide yourself. See   fusus.convert.tsvFromLakhnawi (not the pipeline, but a reverse engineering effort, see  fusus.lakhnawi )   fusus.convert.tsvFromAffifi   fusus.convert.tsvFromCommentary   fusus.convert.tsvFromBook "
},
{
"ref":"fusus.about.methods",
"url":11,
"doc":" Cleaning  Histogram We make a histogram of pixel densities in vertical and horizontal lines. These can be used to derive line boundaries.  Page division  Wiping marks"
},
{
"ref":"fusus.about.model",
"url":12,
"doc":" OCR Models for Kraken Here are the models we use for doing OCR with [Kraken](https: github.com/mittagessen/kraken):  Arabic Generaized Model from [OpenITI](https: github.com/OpenITI/OCR_GS_Data). The file we are using is this one exactly (the commit is specified): [OCR_GS_Data/ara/abhath/arabic_generalized.mlmodel](https: github.com/OpenITI/OCR_GS_Data/blob/1e41e57f1e3c36b40d439f87ad0685d2c2316099/ara/abhath/arabic_generalized.mlmodel)"
},
{
"ref":"fusus.about.work",
"url":13,
"doc":""
},
{
"ref":"fusus.about.sources",
"url":14,
"doc":" Availability Some sources are not publicly available in this repository. They are in the directory _local_, which is excluded from git tracking. These files might be available upon request to [Cornelis van Lit](https: digitalorientalist.com/about-cornelis-van-lit/). All results obtained from these source materials are publicly available.  ! caution \"No editorial material\" We have taken care to strip all editorial material from the sources. We only process the original, historical portions of the texts.  ! hint \"Intermediate results are reproducible\" This repository may or may not contain intermediate results, such as proofing pages, cleaned images, pages with histograms. By running the pipeline again, these results can be reproduced, even without recourse to the original materials in the  _local directory.  Fusus Al Hikam The seminal work is the Fusus Al Hikam (Bezels of Wisdom) by [Ibn Arabi 1165-1240](https: en.wikipedia.org/wiki/Ibn_Arabi). We use two editions, by Lakhnawi and by Affifi.  Lakhnawi edition Cornelis obtained by private means a pdf with the typeset text in it. The text cannot be extracted by normal means due to a range of problems, among with the unusual encoding of Arabic characters to drive special purpose fonts. We have reversed engineered the pdf and produced versions in tsv files, plain text, html, Text-Fabric as well as raster images. The pdf that we worked from is not in the repository, but the results are in the  ur/Lakhnawi directory. The Text-Fabric result is in the  tf/fusus/Lakhnawi directory, where versioned releases of the tf data reside.  Affifi edition Cornelis obtained a pdf with the text as page images in it. We have used the fusus pipeline to extract the full text involving OCR. The pdf that we worked from is not in the repository, but the results are in the  ur/Affifi directory.  Commentaries Cornelis has prepared page images for several commentaries, which we have carried through the fusus pipeline. The results are in the  ur/xxx directories, where  xxx stands for the acronym of the commentary."
},
{
"ref":"fusus.about.tweak",
"url":15,
"doc":""
},
{
"ref":"fusus.about.explore",
"url":16,
"doc":" Explore There are various ways in which you can observe and check the outcome of the pipeline process.  Intermediate results If not in  batch mode, a wide range of intermediate results will be produced that you can inspect.  Proofing After the OCR step, the results can be collected and overlayed on the original page image, where coloring is used to indicate the lavel of confidence of the OCR for that particular word or letter.  Notebooks You find example explorations in the notebooks. They can best be viewed through  nbviewer ."
},
{
"ref":"fusus.about.install",
"url":17,
"doc":" Convention A lot of configuration can be avoided by this simple convention: Put your cloned version of this repository in your  ~/github directory. If you do not have it, make it, and organize it exactly as GitHub is organized: by organization and then by repo.  Get the software Clone the  among/fusus repo from GitHub. Here are the instructions to get this repo and place it in the conventional place on your file system.  sh cd mkdir github cd github mkdir among git clone https: github.com/among/fusus cd fusus   If you want to update later, make sure that you do not have work of your own in this repo. If you have, copy it to a location outside of this repo.  sh cd ~/github/among/fusus git fetch origin git checkout master git reset  hard origin/master    Install the software You are going to install the Python package  fusus that is contained in the repo. During install, all the packages that  fusus is dependent on, will be installed into your current Python3 installation. The package  fusus itself will be added to your Python3 installation in such a way that it can be used from anywhere, while the package inside the repo is being accessed. This is achieved by the fact that the installer will create a link to the repo.  sh cd ~/github/among/fusus pip3 install -e .    ? caution \"Mind the dot\" Do not forget the  . at the end of the line in the above instruction.  ? hint \"No nead to repeat this step\" When you update the repo later, it will not be necessary to redo the  pip3 install step, because the soft link to the fusus package in the repo will still be valid.  Build steps The following steps are relevant if you modify the software and documentation. There is a script  build.py in the top-level directory that performs these tasks. Go to the repo's top level directory and say  sh python3 build.py  help   to see what it can do. Tip: in your  .zshrc define this function:  sh function fsb { cd ~/github/among/fusus python3 build.py \"$@\" }   Then you can invoke the build script from anywhere:  sh fsb  help    Documentation The docs are here:  the README file of the repository;  the docstrings in the Python files in the  fusus package;  the markdown files in the  docs subdirectory of the  fusus package.  View documentation locally To open a browser and view the dynamically generated documentation, say  sh fsb docs    ! caution \"Limited functionality\" The search function does not work here, and images will not display. This way of local browsing the docs has the advantage that changes in the docs are detected when you save them, so that you can see the effect immediately.  Generate documentation locally To generate documentation, say  sh fsb pdocs   The documentation is now in the  site directory. Go to the  index.html file there and open it in your browser. Images and search will work, but if you modify the documentation sources, you have to issue this command again to see the changes.  Publish documentation online To generate and publish documentation online, say  sh fsb sdocs   This will publish the documentation to the  gh-pages branch in the online GitHub repository  among/fusus , from where it can be accessed by [https: among.github.io/fusus/](https: among.github.io/fusus/).  Push everything To generate and publish code and/or documentation and to push all changes to the  main branch in the online GitHub directory, say  sh fsb ship \"commit message\"   You have to provide a commit message."
},
{
"ref":"fusus.about.cheatsheet",
"url":18,
"doc":"All functions below are illustrated in the example [notebook](https: nbviewer.jupyter.org/github/among/fusus/blob/master/example/doExample.ipynb)  Book   from fusus.book import Book    B = Book() : start up :  fusus.book.Book  B.showSettings(params) : show settings :  fusus.book.Book.showSettings : See also  fusus.parameters  B.availableBands() : show the bands defined for this book :  fusus.book.Book.availableBands  B.availableMarks() : show the marks defined for this book :  fusus.book.Book.availableMarks  B.availablePages() : show the page ranges contained in this book :  fusus.book.Book.availablePages  B.configure( kwargs) : modify settings, bands, marks :  fusus.book.Book.configure : See also  fusus.parameters  lastPage = B.process() : Process all pages in a book and return a handle to the last processed page. :  fusus.book.Book.process  lastPage = B.process(pages=\"48-60,67\", doOcr=False) : Process all specified pages and return a handle to the last processed page. Skip OCR. :  fusus.book.Book.process  Page  page = B.process(pages=\"48\", doOcr=False, batch=False) : Process all specified pages and return a handle to the last processed page. Skip OCR. Retain intermediate data for inspection. :  fusus.book.Book.process  page.show( options) : show the data/images of all intermediate stages that the page went through during processing. :  fusus.page.Page.show  page.show(stage='histogram,cleanh') : show specific stages :  fusus.page.Page.show : See also  fusus.parameters.STAGES  page.show(stage=stages, band='histogram,cleanh') : show specific stages with specific bands marked/ :  fusus.page.Page.show : See also  fusus.parameters.BAND_COLORS  page.show(stage='boxed', band=\"high,mid\", mark=\"comma,a\") : show specific marks only :  fusus.page.Page.show  page.write(stage='histogram') : write some or all stages of the page to disk :  fusus.page.Page.write "
},
{
"ref":"fusus.about.howto",
"url":19,
"doc":" Install  Get Fusus Clone the repo from GitHub and install  fusus , which is a Python package with  pip3 . Note that we install fusus  fusus from the clone, not from the global, online PyPI repository. [install - get](https: among.github.io/fusus/fusus/about/install.html get-the-software)  Update documentation Edit the sources of documentation in your local repo clone and use a set of build commands to display and publish the modified docs. [install - documentation](https: among.github.io/fusus/fusus/about/install.html documentation)  Update fusus If you have changed the code for  fusus and/or its documentation, use a build command. [install - push](https: among.github.io/fusus/fusus/about/install.html push-everything)  Run  Run a book in batch There are simple commands to run the pipeline on Arabic books. [run - book batch](https: among.github.io/fusus/fusus/about/run.html book-in-batch)  Explore To follow the pipeline and the Lakhnawi reverse engineering in its tracks, work within a Jupyter notebook, where you can process individual pages and inspect all intermediate results and perform proofing of final results. [explore - notebooks](https: among.github.io/fusus/fusus/about/explore.html notebooks)  Tweak  Engineer  Work"
},
{
"ref":"fusus.lines",
"url":20,
"doc":""
},
{
"ref":"fusus.lines.getInkDistribution",
"url":20,
"doc":"Add line band data to all blocks based on histograms. By means of histograms we can discern where the lines are. We define several bands with respect to lines, such as main, inter, broad, high, mid, low. We also define a band for the space between lines. We mark the main bands on the  layout layer by a starting green line and an ending red line and the space between them will be overlaid with gray. Parameters      C: object Configuration settings stages: dict We need access to several intermediate results. pageH: int size of a full page in pixels blocks: dict The blocks as delivered by  getBlocks . The blocks dict will be updated: each block value gets a new key  bands with the band data. batch: boolean Whether we run in batch mode. boxed: boolean Whether we run in boxed mode (generate boxes around wiped marks). Returns    - list A list of keys in the blocks dict that correspond to blocks that turn out to be devoid of written material.",
"func":1
},
{
"ref":"fusus.lines.getInkX",
"url":20,
"doc":"Make a horizontal histogram of an input region of interest. Optionally draw the histograms on the corresponding roi of an output image. Parameters      imgIn: np array Input image. top, bottom, left, right: int Region of interest on input and output image. imgOut: np array, optional  None Output image. Returns    - histX: list The X histogram",
"func":1
},
{
"ref":"fusus.lines.firstNonzero",
"url":20,
"doc":"",
"func":1
},
{
"ref":"fusus.lines.lastNonzero",
"url":20,
"doc":"",
"func":1
},
{
"ref":"fusus.lines.getHist",
"url":20,
"doc":"",
"func":1
},
{
"ref":"fusus.lines.getInkY",
"url":20,
"doc":"Determine the line distribution in a block of text. Optionally draw the histogram and the peaks and valleys on the corresponding roi of an output image. In this operation, we determine the regular line height by analysing the peaks and the distances between them. But if we have just one peak, we do not have distances. In those cases, we take the last line height that has been calculated. Parameters      C: object The configuration object of the book engine. info: function To write messages to the console imgIn: np array Input image. pageH: int size of a full page in pixels top, bottom, left, right: int Region of interest on input and output image. final: boolean When computing the layout of a page, we call this function to adjust the vertical sizes of blocks. This is a non-final call to this function. Later, we determine the lines per block, that is the final call. When debugging, it is handy to be able to distinguish the debug information generated by these calls. imgOut: np array, optional  None Output image. Returns    - lines: list The detected lines, given as a list of tuples of upper and lower y coordinates",
"func":1
},
{
"ref":"fusus.ocr",
"url":21,
"doc":"Kraken Arabic model: [OpenITI](https: github.com/OpenITI/OCR_GS_Data/blob/master/ara/abhath/arabic_generalized.mlmodel) We can call Kraken with a batch of images. We can call binarization and segmentation and ocr in one call, but then we do not get the line segmentation json file. So we split it up in three batch calls: one for binarize, one for segmentation, and one for ocr. Alternatively, we can do binarization and segmentation in our preprocessing, and use Kraken for OCR only."
},
{
"ref":"fusus.ocr.getProofColor",
"url":21,
"doc":"",
"func":1
},
{
"ref":"fusus.ocr.showConf",
"url":21,
"doc":"",
"func":1
},
{
"ref":"fusus.ocr.OCR",
"url":21,
"doc":"Sets up OCR with Kraken."
},
{
"ref":"fusus.ocr.OCR.ensureLoaded",
"url":21,
"doc":"",
"func":1
},
{
"ref":"fusus.ocr.OCR.read",
"url":21,
"doc":"Perfoms OCR with Kraken.",
"func":1
},
{
"ref":"fusus.ocr.OCR.proofing",
"url":21,
"doc":"Produces an OCR proof page",
"func":1
},
{
"ref":"fusus.ocr.removeMargins",
"url":21,
"doc":"",
"func":1
},
{
"ref":"fusus.ocr.addWord",
"url":21,
"doc":"",
"func":1
},
{
"ref":"fusus.parameters",
"url":22,
"doc":"Settings and configuration"
},
{
"ref":"fusus.parameters.COLORS",
"url":22,
"doc":"Named colors."
},
{
"ref":"fusus.parameters.BAND_COLORS",
"url":22,
"doc":"Band colors. Each band will be displayed in its own color."
},
{
"ref":"fusus.parameters.STAGES",
"url":22,
"doc":"Stages in page processing. When we process a scanned page, we produce named intermediate stages, in this order. The stage data consists of the following bits of information:  kind: image or data (i.e. tab separated files with unicode data).  colored: True if colored, False if grayscale, None if not an image  extension: None if an image file, otherwise the extension of a data file, e.g.  tsv "
},
{
"ref":"fusus.parameters.SETTINGS",
"url":22,
"doc":"Customizable settings. These are the settings that can be customized in several ways. The values here are the default values. When the pipeline is run in a book directory, it will look for a file  parameters.yaml in the toplevel directory of the book where these settings can be overridden. In a program or notebook you can also make last-minute changes to these parameters by calling the  fusus.book.Book.configure method which calls the  Config.configure method. The default values can be inspected by expanding the source code. debug : Whether to show (intermediate) results. If  0 : shows nothing, if  1 : shows end result, if  2 : shows intermediate results. inDir : name of the subdirectory with page scans outDir : name of the subdirectory with the final results of the workflow interDir : name of the subdirectory with the intermediate results of the workflow cleanDir : name of the subdirectory with the cleaned, blockwise images of the workflow marksDir : name of the subdirectory with the marks skewBorder : the width of the page margins that will be whitened in order to suppress the sharp black triangles introduces by skewing the page blurX : the amount of blur in the X-direction. Blurring is needed to get better histograms To much blurring will hamper the binarization, see e.g. pag 102 in the examples directory: if you blur with 41, 41 binarization fails. blurY : the amount of blur in the X-direction. Blurring is needed to get betterskewing and histograms.  ! caution \"Amount of Y-blurring\" Too much vertical blurring will cause the disappearance of horizontal bars from the histogram. Footnote bars will go undetected. Too little vertical blurring will result in ragged histograms, from which it is difficult to get vertical line boundaries. marginThresholdX : used when interpreting horizontal histograms. When histograms for horizontal lines cross marginThresholdY, it will taken as an indication that a line boundary (upper or lower) has been reached. contourFactor : used when computing left and right contour lines of a page. Each horizontal line as a left most black pixel and a rightmost one. Together they form the left contour and the right contour of the page. The length of each line is the distance between the left contour and right contour points on that line. However, to be useful, the contour lines must be smoothed. We look up and down from each contour point and replace it by the median value of the contour points above and below that point. How far do we have to look? We want to neutralize the interline spaces, so we look up and down for a fraction line line height. That fraction is specified by this parameter. A proxy for the line height is the peak distance. peakSignificant : used when interpreting histograms for line detection When we look for significant peaks in a histogram, we determine the max peak height. Significant peaks are those that have a height greater than a specific fraction of the max peak height. This parameter states that fraction. peakTargetWidthFraction : used when interpreting histograms for line detection When we have studied the significant peaks and found the regular distance between successive peaks, we use that to pass as the  distance parameter to the SciPy [find_peaks](https: docs.scipy.org/doc/scipy/reference/generated/scipy.signal.find_peaks.html scipy.signal.find_peaks) algorithm. We get the best results if we do not pass the line height itself, but a fraction of it. This parameter is that fraction. peakProminenceY, valleyProminenceY : used when interpreting histograms for line detection We detect peaks and valleys in the histogram by means of a SciPy algorithm, to which we pass a prominence parameter. This will leave out minor peaks and valleys. outerValleyShiftFraction : used when interpreting histograms for line detection The valleys at the outer ends of the histogram tend to be very broad and hence the valleys will be located too far from the actual ink. We correct for that by shifting those valleys a fraction of their plateau sizes towards the ink. This parameter is that fraction. defaultLineHeight : used for line detection After line detection, a value for the line height is found and stored in this parameter. The parameter is read when there is only one line on a page, in which case the line detection algorithm has too little information. If this occurs at the very first calculation of line heights, a fixed default value is used. accuracy : When marks are searched for in the page, we get the result in the form of a grayscale page where the value in each point reflects how much the page in that area resembles the mark. Only hits above the value of  accuracy will be considered. connectBorder : When marks are found, each hit will be inspected: is the ink in the hit connected to the ink outside the hit? This will be measured in an inner and outer border of the page, whose thickness is given by this parameter. connectThreshold : After computing inner and outer borders, they will be inverted, so that black has the maximum value. Then the inside and outside borders are multiplied pixel wise, so that places where they are both black get very high values. All places where this product is higher than the value of  connectThreshold are retained for further calculation. connectRatio : After computing the places where inner and outer borders contain joint ink, the ratio of such places with respect to the total border size is calculated. If that ratio is greater than  connectRatio , the hit counts as connected to its surroundings. We have not found a true instance of the mark, and the mark will not be cleaned. boxBorder : The hits after searching for marks will be indicated on the  boxed stage of the page by means of a small coloured border around each hit. The width of this border is  boxBorder . maxHits : When searching for marks, there are usually multiple hits: the place where the mark occurs, and some places very nearby. The cleaning algorithm will cluster nearby hits and pick the best hit per cluster. But if the number of hits is very large, it is a sign that the mark is not searched with the right accuracy, and clustering will be prevented. It would become very expensive, and useless anyway. A warning will be issued in such cases. bandMain : Offsets for the  main band. Given as  (top, bottom) , with  top and  bottom positive or negative integers. This band covers most of the ink in a line. The  main band is computed from the histogram after which the height of the top and bottom boundaries are adjusted relative to the values obtained by the histogram algorithm. You can adjust these values: higher values move the boundaries down, lower values move them up. In practice, the adjustments are zero for the main band, while all other bands are derived from the main band by applying adjustments. bandInter : Offsets for the  inter band. This band covers most of the white between two lines. The  inter band is computed from the histogram. bandBroad : Offsets for the  broad band. This band s like  main but covers even more ink in a line. bandMid : Offsets for the  mid band. This band s like  main but covers the densest part in a line. bandHigh : Offsets for the  high band. This band s like  inter but covers the upper part of the letters and the white space above it. bandLow : Offsets for the  low band. This band s like  inter but covers the lower part of the letters and the white space below it."
},
{
"ref":"fusus.parameters.Config",
"url":22,
"doc":"Settings manager. It will expose all settings as attributes to the rest of the application. It has methods to collect modified settings from the user and apply them. The default settings are kept as a separate copy that will not be changed in any way. User modifications act on the current settings, which have been obtained by deep-copying the defaults. Parameters      tm: object Can display timed info/error messages to the display params: dict key-value pairs that act as updates for the settings. If a value is  None , the original value will be reinstated."
},
{
"ref":"fusus.parameters.Config.configure",
"url":22,
"doc":"Updates current settings based on new values. User modifications act on the current settings, which have been obtained by deep-copying the defaults. Parameters      reset: boolean, optional  False If  True , a fresh deep copy of the defaults will be made and that will be the basis for the new current settings. params: dict key-value pairs that act as updates for the settings. If a value is  None , the original value will be reinstated.",
"func":1
},
{
"ref":"fusus.parameters.Config.show",
"url":22,
"doc":"Display current settings. Parameters      params: str, optional  None If  None , all settings will be displayed. Else it should be a comma-separated string of legal parameter names whose values are to be displayed.",
"func":1
},
{
"ref":"fusus.book",
"url":23,
"doc":"Book workflow We will transform scanned pages of a book into Unicode text following a number of processing steps.  The express way In the terminal,  cd to a book directory (see below) and run   python3 -m fusus.book   This will process all scanned pages with default settings.  With more control and feedback Copy the notebook  example/do.ipynb into a book directory (see below). Run cells in the notebook, and see [doExample](https: github.com/among/fusus/blob/master/example/doExample.ipynb) to learn by example how you can configure the processing parameters and control the processing of pages.  Book directory A book directory should have subdirectories at the outset:   in Contains image files (scans at 1800 x2700 pixels approximately);   marks (optional) Contains subdirectories with little rectangles copied from the scans and saved in individual files at the same resolution.  Marks Marks are spots that will be wiped clean wherever they are found. They are organized in  bands which are sets of horizontal strokes on the page, relative to the individual lines. Marks will only be searched for within the bands they belong to, in order to avoid false positives. The  marks directory may contain the following bands: name | kind | items | remarks  - |  - |  - |  -  high | marks | arbitrary images | in the upper band of a line  low | marks | arbitrary images | in the lower band of a line  mid | marks | arbitrary images | in the central, narrow band of a line, with lots of ink  main | marks | arbitrary images | in the band where nearly all the letter material is  broad | marks | arbitrary images | as  main , but a bit broader  inter | marks | arbitrary images | between the lines When fusus reads the marks, it will crop all white borders from it and surround the result with a fixed small white border. So you do not have to be very precise in trimming the mark templates. After running the pipeline, the following subdirectories may have been produced:   inter Intermediate files, such as page images with histograms displayed in it, or data files with information on the marks that have been encountered and wiped;   clean Cleaned page block images, input for OCR processing.   out Output (= final results). Tab separated files with one row per word.   proof Aids to assess the quality of the output. Tab separated files with one row per character. Normalized input images. Overlay HTML files with OCR results, coloured by confidence, both on character basis and on word basis.   text Plain HTML rendering of the full, recognized text with page and line indicators. Used for reading the results by human eyes.  ! caution \"Block information\" If the layout algorithm has divided the page into blocks, the information of the blocks resides in the page object and is not currently stored on disk. This information is needed after OCR to shift the coordinates with respect to the blocks 9this is what comes out of the OCR) to coordinates with respect to the page. That means you cannot initialize the pipeline with the clean block images as sole input. You have to start with layout detection."
},
{
"ref":"fusus.book.Book",
"url":23,
"doc":"Engine for book conversion. Parameters      cd: string, optional If passed, performs a change directory to the directory specified. Else the whole book processing takes place in the current directory. You can use  ~ to denote your home directory. params: dict, optional Any number of customizable settings from  fusus.parameters.SETTINGS . They will be in effect when running the workflow, until a  Book.configure action will modify them."
},
{
"ref":"fusus.book.Book.configure",
"url":23,
"doc":"Updates current settings based on new values. The signature is the same as  fusus.parameters.Config.configure .",
"func":1
},
{
"ref":"fusus.book.Book.showSettings",
"url":23,
"doc":"Display settings. Parameters      params: dict, optional Any number of customizable settings from  fusus.parameters.SETTINGS . The current values of given parameters will be displayed. The values that you give each of the  params here is not used, only their names. It is recommended to pass  None as values:  B.showSettings(blurX=None, blurY=None) ",
"func":1
},
{
"ref":"fusus.book.Book.availableBands",
"url":23,
"doc":"Display the characteristics of all defined  bands .",
"func":1
},
{
"ref":"fusus.book.Book.availableMarks",
"url":23,
"doc":"Display the characteristics of defined  marks . Parameters      band: string, optional  None Show only marks in this band. If  None , show marks in all bands. mark: string, optional  None Show only marks in with this name. If  None , show marks with any name.",
"func":1
},
{
"ref":"fusus.book.Book.availablePages",
"url":23,
"doc":"Display the amount and page numbers of all pages.",
"func":1
},
{
"ref":"fusus.book.Book.process",
"url":23,
"doc":"Process directory of images. Executes all processing steps for all images. Parameters      pages: string | int, optional  None Specification of pages to do. If absent or  None : all pages. If an int, do only that page. Otherwise it must be a comma separated string of (ranges of) page numbers. Half ranges are also allowed:  -10 (from beginning up to and including  10 ) and  10- (from 10 till end). E.g.  1 and  5-7 and  2-5,8-10 , and  -10,15-20,30- . No spaces allowed. batch: boolean, optional  True Whether to run in batch mode. In batch mode everything is geared to the final output. Less intermediate results are computed and stored. Less feedback happens on the console. boxed: boolean, optional  False If in batch mode, produce also images that display the cleaned marks in boxes. quiet: boolean, optional  True Whether to suppress warnings and the display of stroke separators. doOcr: boolean, optional  True Whether to perform OCR processing uptoLayout: boolean, optional  False Whether to stop after doing layout Returns    - A  fusus.page.Page object for the last page processed, which is the handle for further inspection of what has happened during processing.",
"func":1
},
{
"ref":"fusus.book.Book.stageDir",
"url":23,
"doc":"",
"func":1
},
{
"ref":"fusus.book.Book.measureQuality",
"url":23,
"doc":"Measure the reported quality of the ocr processing. pages: string | int, optional  None Specification of pages to do. If absent or  None : all pages. If an int, do only that page. Otherwise it must be a comma separated string of (ranges of) page numbers. Half ranges are also allowed:  -10 (from beginning up to and including  10 ) and  10- (from 10 till end). E.g.  1 and  5-7 and  2-5,8-10 , and  -10,15-20,30- . No spaces allowed. showStats: boolean, optional  True Compute and show quality statistics updateProofs: boolean, optional  False If true, regenerate all proofing pages. This is desriable if you have tweaked the coloring of OCR results depending on the confidence. The OCR itself does not have to be performed again for this.",
"func":1
},
{
"ref":"fusus.book.Book.exportTsv",
"url":23,
"doc":"Combine the tsv data per page to one big tsv file. pages: string | int, optional  None Specification of pages to do. If absent or  None : all pages. If an int, do only that page. Otherwise it must be a comma separated string of (ranges of) page numbers. Half ranges are also allowed:  -10 (from beginning up to and including  10 ) and  10- (from 10 till end). E.g.  1 and  5-7 and  2-5,8-10 , and  -10,15-20,30- . No spaces allowed. The output is written to the working directory.",
"func":1
},
{
"ref":"fusus.book.Book.plainText",
"url":23,
"doc":"Get the plain text from the ocr output in one file pages: string | int, optional  None Specification of pages to do. If absent or  None : all pages. If an int, do only that page. Otherwise it must be a comma separated string of (ranges of) page numbers. Half ranges are also allowed:  -10 (from beginning up to and including  10 ) and  10- (from 10 till end). E.g.  1 and  5-7 and  2-5,8-10 , and  -10,15-20,30- . No spaces allowed. The output is written to the  text subdirectory.",
"func":1
},
{
"ref":"fusus.book.main",
"url":23,
"doc":"Process a whole book with default settings. Go to the book directory and say   python3 -m fusus.book [pages]   where  pages is an optional string specifying ranges of pages as in  Book.process ",
"func":1
},
{
"ref":"fusus.convert",
"url":24,
"doc":"Convenience scripts to call conversions. These scripts support one-liners on the command line to execute the pipeline and various conversion processes."
},
{
"ref":"fusus.convert.tfFromTsv",
"url":25,
"doc":""
},
{
"ref":"fusus.convert.tfFromTsv.generic",
"url":25,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tfFromTsv.getToc",
"url":25,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tfFromTsv.getFile",
"url":25,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tfFromTsv.convert",
"url":25,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tfFromTsv.director",
"url":25,
"doc":"Read tsv data fields. Fields are integer valued, except for fields with names ending in $. If a row comes from the result of OCR we have the fields:   stripe block$ line left top right bottom confidence text$   We prepend the page number in this case, yielding   page stripe block$ line left top right bottom confidence text$   Otherwise we have: page line column span direction$ left top right bottom text$ The block in an OCRed file is either  r or  l or nothing, it corresponds to material to the left and right of a vertical stroke. If there is no vertical stroke, there is just one block. The column in a non OCRed file is either  1 or  2 and comes from a line partitioned into two regions by means of white space. In both cases, the first 4 fields denote a sectional division in the words.",
"func":1
},
{
"ref":"fusus.convert.tfFromTsv.loadTf",
"url":25,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tfFromTsv.parseArgs",
"url":25,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tfFromTsv.main",
"url":25,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tsvFromCommentary",
"url":26,
"doc":"Run the pipeline on a commentary   python3 -m fusus.convert.tsvFromCommentary commentary   The commentary will be looked up inside the  ur directory of the repo. This command can be run from any directory."
},
{
"ref":"fusus.convert.tsvFromAffifi",
"url":27,
"doc":"Run the pipeline on the Fusus Al Hikam (Affifi edition)   python3 -m fusus.convert.tsvFromAffifi   This command can be run from any directory."
},
{
"ref":"fusus.convert.tsvFromLakhnawi",
"url":28,
"doc":"Run the pipeline on the Fusus Al Hikam (Lakhnawi edition)   python3 -m fusus.convert.tsvFromLakhnawi   This command can be run from any directory."
},
{
"ref":"fusus.convert.tsvFromLakhnawi.main",
"url":28,
"doc":"",
"func":1
},
{
"ref":"fusus.convert.tsvFromBook",
"url":29,
"doc":"Run the pipeline on a book   python3 -m fusus.convert.tsvFromBook path_to_book_directory   The path to the book directory is either absolute or relative to the current directory. Use this command to convert books of your own that are not already in this repo. This command can be run from any directory."
},
{
"ref":"fusus.convert.tsvFromBook.doBook",
"url":29,
"doc":"",
"func":1
}
]