<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pipeline.page API documentation</title>
<meta name="description" content="Single page processing." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pipeline.page</code></h1>
</header>
<section id="section-intro">
<p>Single page processing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/150ca46e478e369dd6ab4edeb7f2ad2e9f841f57/pipeline/page.py#L0-L807" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Single page processing.
&#34;&#34;&#34;

import os
import cv2
import numpy as np
from IPython.display import HTML, display

from .lib import (
    addBox,
    applyHRules,
    cluster,
    connected,
    getBlocks,
    getHistograms,
    getStretches,
    getStripes,
    grayInterBlocks,
    parseBands,
    parseMarks,
    parseStages,
    reborder,
    removeSkewStripes,
    showImage,
    splitext,
    storeCleanInfo,
)
from .ocr import OCR


class Page:
    def __init__(self, engine, f, batch=False, boxed=True):
        &#34;&#34;&#34;All processing steps for a single page.

        Parameters
        ----------
        engine: object
            The `pipeline.book.Book` object
        f: string
            The file name of the scanned page with extension, without directory
        batch: boolean, optional `False`
            Whether to run in batch mode.
            In batch mode everything is geared to the final output.
            Less intermediate results are computed and stored.
            Less feedback happens on the console.
        boxed: boolean, optional `True`
            If in batch mode, produce also images that display the cleaned marks
            in boxes.
        &#34;&#34;&#34;

        self.engine = engine
        C = engine.C
        tm = engine.tm
        error = tm.error
        self.file = f
        (self.bare, self.ext) = splitext(f, withDot=False)
        self.empty = True
        self.batch = batch
        self.boxed = boxed
        self.stages = {}

        inDir = C.inDir
        path = f&#34;{inDir}/{f}&#34;
        if not batch and not os.path.exists(path):
            error(f&#34;Page file not found: {path}&#34;)
            return

        self.empty = False
        orig = cv2.imread(path)

        self.stages = {&#34;orig&#34;: orig}

    def show(self, stage=None, band=None, mark=None, **displayParams):
        &#34;&#34;&#34;Displays processing stages of an page.

        See `pipeline.parameters.STAGES`.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.
        band: string | iterable, optional `None`
            If no band is passed, no bands are indicated.
            Otherwise, the indicated bands are shown.
            If a string, it may be a comma-separated list of band names.
            Otherwise it is an iterable of band names.
        mark: string | iterable, optional `None`
            If `None` is passed, no marks are shown.
            If `&#34;&#34;` is passed, all marks on the selected bands are shown.
            Otherwise, the indicated mark boxes are shown, irrespective
            of their bands:
            If given as a string, it may be a comma-separated list of mark names.
            Otherwise it is an iterable of mark names.
            This information will be taken from the result of the `markData` stage.
        display: dict, optional
            A set of display parameters, such as `width`, `height`
            (anything accepted by `IPython.display.Image`).

        Notes
        -----
        The mark option works for the &#34;boxed&#34; stage:
        All marks not specified in the mark parameter will not be shown.

        But this option also works for all other image stages: the marks
        will be displayed on a fresh copy of that stage.

        When used for a grayscale stage, the color of the mark boxes is lost.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C

        stages = self.stages
        marks = engine.marks
        blocks = self.blocks

        for s in parseStages(stage, set(stages), C.stageOrder, error):
            stageData = stages[s]

            (stageType, stageExt) = C.stages[s]
            if stageType == &#34;data&#34;:
                self._serial(s, stageData, stageExt)
            else:
                img = stageData

                headingInfo = []

                if band is not None or mark is not None:
                    img = (
                        stages[&#34;demarginedC&#34;]
                        if s == &#34;boxed&#34; and mark is not None
                        else stageData
                    ).copy()
                    for ((stripe, column), data) in blocks.items():

                        bands = data[&#34;bands&#34;]
                        doBands = (
                            () if band is None else parseBands(band, set(bands), error)
                        )
                        doBandSet = set(doBands)
                        bandRep = f&#34; with bands {&#39;, &#39;.join(doBands)}&#34; if doBands else &#34;&#34;
                        doMarks = (
                            set()
                            if mark is None
                            else parseMarks(mark, marks, set(doBands), error)
                        )
                        markRep = (
                            f&#34; with marks {&#39;, &#39;.join(sorted(doMarks))}&#34;
                            if doMarks
                            else &#34;&#34;
                        )
                        headingInfo.append(f&#34;&lt;b&gt;{stripe}{column}&lt;/b&gt; {bandRep}{markRep}&#34;)

                        (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                        imBW = rightB - leftB
                        for band in doBands:
                            bandInfo = bands[band]
                            uppers = bandInfo[&#34;uppers&#34;]
                            lowers = bandInfo[&#34;lowers&#34;]
                            bColor = bandInfo[&#34;color&#34;]
                            for (upper, lower) in zip(uppers, lowers):
                                theUpper = topB + upper
                                theLower = topB + lower
                                theLeft = leftB + 10
                                theRight = leftB + imBW - 10
                                cv2.rectangle(
                                    img,
                                    (theLeft, theUpper),
                                    (theRight, theLower),
                                    bColor,
                                    2,
                                )
                                cv2.rectangle(
                                    img,
                                    (leftB, theUpper),
                                    (theLeft, theLower),
                                    bColor,
                                    -1,
                                )
                                cv2.rectangle(
                                    img,
                                    (theRight, theUpper),
                                    (leftB + imBW, theLower),
                                    bColor,
                                    -1,
                                )
                    markData = stages.get(&#34;markData&#34;, {})
                    markLegend = {}

                    for (band, bandMarks) in markData.items():
                        if doBands and band not in doBandSet:
                            continue
                        for ((seq, mrk), hits) in bandMarks.items():
                            if mrk not in doMarks:
                                continue
                            markKey = f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;
                            markValue = (band, mrk, len(hits))
                            markLegend[markKey] = markValue
                            for (
                                kept,
                                value,
                                connDegree,
                                connectBorder,
                                stripe,
                                column,
                                top,
                                bottom,
                                left,
                                right,
                            ) in hits:
                                addBox(
                                    C,
                                    img,
                                    top,
                                    bottom,
                                    left,
                                    right,
                                    kept,
                                    band,
                                    seq,
                                    connDegree,
                                )

                    if markLegend:
                        html = []
                        html.append(
                            &#34;&lt;details open&gt;&lt;summary&gt;Mark legend&lt;/summary&gt;&lt;table&gt;&#34;
                        )
                        html.append(
                            &#34;&lt;tr&gt;&lt;th&gt;acro&lt;/th&gt;&lt;th&gt;band&lt;/th&gt;&#34;
                            &#34;&lt;th&gt;mark&lt;/th&gt;&lt;th&gt;hits&lt;/th&gt;&lt;/tr&gt;&#34;
                        )
                        for (k, (b, m, n)) in sorted(markLegend.items()):
                            html.append(
                                f&#34;&lt;tr&gt;&lt;td&gt;{k}&lt;/td&gt;&lt;td&gt;{b}&lt;/td&gt;&#34;
                                f&#34;&lt;td&gt;{m}&lt;/td&gt;&lt;td&gt;{n}&lt;/td&gt;&lt;/tr&gt;&#34;
                            )
                        html.append(&#34;&lt;/table&gt;&lt;/details&gt;&#34;)
                        display(HTML(&#34;&#34;.join(html)))
                display(
                    HTML(f&#34;&lt;div&gt;{s} {&#39;;&#39;.join(headingInfo)}&lt;/div&gt;&#34;)
                )
                showImage(img, **displayParams)

    def write(self, stage=None):
        &#34;&#34;&#34;Writes processing stages of an page to disk.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.

        Returns
        -------
        None
            The stages are written into the `inter` subdirectory,
            with the name of the stage appended to the file name.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C
        interDir = C.interDir

        bare = self.bare
        ext = self.ext
        stages = self.stages

        for s in parseStages(stage, set(C.stages), C.stageOrder, error):
            if s not in stages:
                continue
            stageData = stages[s]
            (stageType, stageExt) = C.stages[s]
            path = f&#34;{interDir}/{bare}-{s}.{stageExt or ext}&#34;
            if stageType == &#34;data&#34;:
                with open(path, &#34;w&#34;) as f:
                    self._serial(s, stageData, stageExt, f)
            else:
                cv2.imwrite(path, stageData)

    def _serial(self, stage, data, extension, handle=None):
        &#34;&#34;&#34;serializes data in accordance with file type.

        Parameters
        ----------
        data:
            The data to serialize. The type of data must be compatible with
            the *extension*.
        extension: string
            The file type according to which the data must be serialized.
        handle: string, optional `None`
            If `None`, output is prepared for display in a Jupter notebook,
            else it is a file handle and the data is serialized
            in the canonical way and written to that file.

        Returns
        -------
        string
            The serialized data.
            If the extension does not match a recognized file type,
            the Python `repr` of the data is returned.

        Notes
        -----
        The following data type/extension combinations are supported:

        extension | data type
        --- | ---
        tsv | tuple/list of tuple/list
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        info = tm.info

        if handle:
            if stage == &#34;markData&#34;:
                data = storeCleanInfo(data)
            handle.write(
                &#34;&#34;.join(&#34;\t&#34;.join(str(column) for column in row) + &#34;\n&#34; for row in data)
                if extension == &#34;tsv&#34;
                else repr(data)
            )
        else:
            if stage == &#34;markData&#34;:
                self._showCleanInfo()
            else:
                info(data, tm=False)

    def _normalize(self):
        &#34;&#34;&#34;Normalizes a page.

        It produces a stage that is unskewed: *rotated* and blurred.
        The same rotation will be applied to the original scan,
        resulting in stage *normalized*.

        Unskewing is needed otherwise the footnote line will not be found.
        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        C = engine.C
        whit = C.whiteGRS

        batch = self.batch
        boxed = self.boxed
        stages = self.stages
        orig = stages[&#34;orig&#34;]

        removeSkewStripes(orig, C.skewBorder, C.whiteRGB)
        gray = cv2.cvtColor(orig, cv2.COLOR_BGR2GRAY)
        stages[&#34;gray&#34;] = gray

        blurred = cv2.GaussianBlur(gray, (C.blurX, C.blurY), 0, 0)

        (th, threshed) = cv2.threshold(
            blurred, 127, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )
        pts = cv2.findNonZero(threshed)
        ret = cv2.minAreaRect(pts)

        (cx, cy), (rw, rh), ang = ret
        if rw &gt; rh:
            rw, rh = rh, rw
            ang += 90

        M = cv2.getRotationMatrix2D((cx, cy), ang, 1.0)

        rotated = cv2.warpAffine(threshed, M, (threshed.shape[1], threshed.shape[0]))
        removeSkewStripes(rotated, C.skewBorder, C.blackRGB)
        normalized = cv2.warpAffine(gray, M, (gray.shape[1], gray.shape[0]))
        removeSkewStripes(normalized, C.skewBorder, whit)

        if not batch or boxed:
            normalizedC = cv2.warpAffine(orig, M, (orig.shape[1], orig.shape[0]))
            removeSkewStripes(normalizedC, C.skewBorder, C.whiteRGB)

        stages[&#34;rotated&#34;] = rotated
        stages[&#34;normalized&#34;] = normalized
        if not batch or boxed:
            stages[&#34;normalizedC&#34;] = normalizedC

    def _layout(self):
        &#34;&#34;&#34;Divide the page into stripes and the stripes into columns.

        We detect vertical strokes as columns separators and horizontal strokes
        as separators to split off top and bottom material.

        A page may or may not be partially divided into columns.
        Where there is a vertical stroke, we define a stripe: the
        horizontal band that contains the vertical stroke tightly and extends to
        the full with of the page.

        Between the stripes corresponding to column separators we have stripes that
        are not split into columns.

        The stripes will be numbered from top to bottom, starting at 1.

        If a stripe is not split, it defines a roi (region of interest) with
        label `(i, &#39;&#39;)`.

        If it is split, it defines blocks with labels `(i, &#39;r&#39;)` and `(i, &#39;l&#39;)`.

        Every horizontal stripe will be examined. W e have to determine whether
        it is a top separator or a bottom separator.
        As a rule of thumb: horizontal stripes in the top stripe are top-separators,
        all other horizontal stripes are bottom separators.

        If there are multiple horizontal strokes in a roi, the most aggressive
        one will be taken, i.e. the one that causes the most matarial to be discarded.

        All further operations will take place on these blocks (and not on the
        page as a whole).

        The result of this stage is, besides the blocks, an image of the page
        with the blocks marked and labelled.
        &#34;&#34;&#34;

        batch = self.batch
        boxed = self.boxed
        engine = self.engine
        C = engine.C
        tm = engine.tm
        indent = tm.indent
        info = tm.info

        stages = self.stages
        if not batch or boxed:
            layout = stages[&#34;normalizedC&#34;].copy()
            stages[&#34;layout&#34;] = layout

        indent(level=3)
        stretchesH = getStretches(C, info, stages, True, batch)
        stretchesV = getStretches(C, info, stages, False, batch)
        stripes = getStripes(stages, stretchesV)
        blocks = getBlocks(C, stages, stripes, batch)
        self.blocks = blocks
        applyHRules(C, stages, stretchesH, stripes, blocks, batch, boxed)
        emptyBlocks = getHistograms(C, stages, blocks, batch, boxed)
        if not batch:
            grayInterBlocks(C, stages, blocks, emptyBlocks)

    def _clean(self, mark=None, block=None, line=None, showKept=False):
        &#34;&#34;&#34;Remove marks from the page.

        The blocks of the page are cleaned of marks.

        New stages of the page are added:

        *   *clean* all targeted marks removed
        *   *cleanh* all targeted marks highlighted in light gray
        *   *boxed* all targeted marks boxed in light gray
        *   *markData* information about each detected mark.

        Parameters
        ----------
        mark: iterable of tuples (band, mark, [params]), optional `None`
            If `None`, all marks that are presented in the book
            directory are used.
            Otherwise, a series of marks is specified together with the band
            where this mark is searched in. Optionally you can also
            put parameters in the tuple: the accuracy, connectBorder and connectRatio.
        block: (integer, string), optional `None`
            Block identifier. If specified, only this block will be cleaned.
            If absent, cleans all blocks.
        line: integer, optional `None`
            Line number specifying the line numbers to clean.
            In all specified blocks, only the line with this number will be cleaned.
            If absent, cleans all lines in the specified blocks.
        showKept: boolean, optional `False`
            Whether to show the mark candidates that are kept.
            If False, kept marks do not show up as green boxes,
            and they do not contribute to the markData layer.
        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        tm = engine.tm
        indent = tm.indent
        info = tm.info
        error = tm.error
        warning = tm.warning
        C = engine.C

        marks = engine.marks
        batch = self.batch
        boxed = self.boxed

        markParams = C.markParams
        boxBorder = C.boxBorder

        connectBorder = C.connectBorder
        threshold = C.connectThreshold
        maxHits = C.maxHits
        color = dict(clean=C.cleanRGB, cleanh=C.cleanhRGB,)

        if mark is None:
            searchMarks = {subdir: markItems for (subdir, markItems) in marks.items()}
        else:
            searchMarks = {}
            for item in mark:
                (band, name) = item[0:2]
                if band not in marks or name not in marks[band]:
                    error(f&#34;No such mark: {band}/{mark}&#34;)
                    continue
                params = item[2] if len(item) &gt; 2 else {}
                for (acro, v) in params.items():
                    if acro not in markParams:
                        error(f&#34;Unknown parameter `{acro}` = `{v}`&#34;)
                configuredMark = marks[band][name]
                seq = configuredMark[&#34;seq&#34;]
                searchMarks.setdefault(band, {})[name] = dict(
                    seq=seq, gray=configuredMark[&#34;gray&#34;]
                )
                for (acro, full) in markParams.items():
                    searchMarks[band][name][full] = params.get(
                        acro, configuredMark[full]
                    )

        stages = self.stages
        demargined = stages.get(&#34;demargined&#34;, stages[&#34;gray&#34;])
        if batch:
            resultStages = (&#34;clean&#34;, &#34;boxed&#34;) if boxed else (&#34;clean&#34;,)
            if boxed:
                demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
        else:
            demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
            resultStages = (&#34;clean&#34;, &#34;cleanh&#34;, &#34;boxed&#34;)
        for stage in resultStages:
            stages[stage] = (demarginedC if stage == &#34;boxed&#34; else demargined).copy()

        tasks = [
            (
                stage,
                stages[stage],
                None if stage == &#34;boxed&#34; else color[stage],
                boxBorder if stage == &#34;boxed&#34; else -1,
            )
            for stage in resultStages
        ]

        foundHits = {}
        cleanClr = color[&#34;clean&#34;]
        blocks = self.blocks
        markResults = {}

        for ((stripe, column), data) in blocks.items():
            if block is not None and block != (stripe, column):
                continue
            (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
            thisDemargined = demargined[topB:bottomB, leftB:rightB]
            if not batch or boxed:
                thisBoxed = stages[&#34;boxed&#34;][topB:bottomB, leftB:rightB]
                theUpper = None
                theLower = None
                maxH = bottomB - topB

            for (band, markData) in searchMarks.items():
                if &#34;bands&#34; not in data:
                    # error(f&#34;No bands in {stripe}{column}&#34;)
                    continue
                bandData = data[&#34;bands&#34;][band]
                uppers = bandData[&#34;uppers&#34;]
                lowers = bandData[&#34;lowers&#34;]

                for (markName, markInfo) in markData.items():
                    foundHits.setdefault(band, {})[markName] = 0
                    seq = markInfo[&#34;seq&#34;]
                    mark = markInfo[&#34;gray&#34;]
                    connectBorder = markInfo[&#34;connectBorder&#34;]
                    accuracy = markInfo[&#34;accuracy&#34;]
                    ratio = markInfo[&#34;connectRatio&#34;]
                    (markH, markW) = mark.shape[:2]

                    nPts = 0
                    clusters = []
                    for (i, (upper, lower)) in enumerate(zip(uppers, lowers)):
                        if line is not None:
                            if i &lt; line - 1:
                                continue
                            elif i &gt; line - 1:
                                break
                        if line is not None and i == line - 1:
                            if theUpper is None or theUpper &gt; upper:
                                theUpper = upper
                            if theLower is None or theLower &lt; lower:
                                theLower = lower

                        roi = thisDemargined[
                            upper : lower + 1,
                        ]
                        (roih, roiw) = roi.shape[:2]
                        if roih &lt; markH or roiw &lt; markW:
                            # search template exceeds roi image
                            continue
                        result = cv2.matchTemplate(roi, mark, cv2.TM_CCOEFF_NORMED)
                        loc = np.where(result &gt;= accuracy)
                        pts = list(zip(*loc))
                        if len(pts) &gt; maxHits:
                            error(
                                f&#34;mark &#39;{band}:{markName}&#39;:&#34;
                                f&#34; too many hits: {len(pts)} &gt; {maxHits}&#34;
                            )
                            warning(&#34;Increase accuracy for this template&#34;)
                            continue
                        if not pts:
                            continue

                        nPts += len(pts)
                        clusters = cluster(pts, result)

                        for (pt, value) in clusters:
                            connDegree = connected(
                                markH, markW, connectBorder, threshold, roi, pt
                            )
                            pt = (pt[0] + upper + topB, pt[1] + leftB)
                            (top, bottom, left, right) = (
                                pt[0],
                                pt[0] + markH,
                                pt[1],
                                pt[1] + markW,
                            )
                            if connDegree &gt; ratio:
                                if showKept and (not batch or boxed):
                                    im = stages[&#34;boxed&#34;]
                                    addBox(
                                        C,
                                        im,
                                        top,
                                        bottom,
                                        left,
                                        right,
                                        True,
                                        band,
                                        seq,
                                        connDegree,
                                    )
                                    markResults.setdefault(band, {}).setdefault(
                                        (seq, markName), []
                                    ).append(
                                        (
                                            True,
                                            value,
                                            connDegree,
                                            connectBorder,
                                            stripe,
                                            column,
                                            top,
                                            bottom,
                                            left,
                                            right,
                                        )
                                    )
                            else:
                                if batch and not boxed:
                                    cv2.rectangle(
                                        stages[&#34;clean&#34;],
                                        (left, top),
                                        (right, bottom),
                                        cleanClr,
                                        -1,
                                    )
                                else:
                                    for (stage, im, clr, brd) in tasks:
                                        isBoxed = stage == &#34;boxed&#34;
                                        if isBoxed:
                                            addBox(
                                                C,
                                                im,
                                                top,
                                                bottom,
                                                left,
                                                right,
                                                False,
                                                band,
                                                seq,
                                                connDegree,
                                            )
                                            markResults.setdefault(band, {}).setdefault(
                                                (seq, markName), []
                                            ).append(
                                                (
                                                    False,
                                                    value,
                                                    connDegree,
                                                    connectBorder,
                                                    stripe,
                                                    column,
                                                    top,
                                                    bottom,
                                                    left,
                                                    right,
                                                )
                                            )
                                        else:
                                            cv2.rectangle(
                                                im,
                                                (left, top),
                                                (right, bottom),
                                                clr,
                                                -1,
                                            )

            if not batch or boxed:
                if line is not None and theUpper is not None and theLower is not None:
                    grace = 20
                    thisTop = max(0, theUpper - grace)
                    thisBottom = min(maxH, theLower + grace)
                    info(
                        f&#34;block {stripe}{column} line {line} BEFORE/AFTER cleaning\n&#34;,
                        tm=False,
                    )
                    roi = thisDemargined[thisTop:thisBottom]
                    showImage(roi)
                    roiBoxed = thisBoxed[thisTop:thisBottom]
                    showImage(roiBoxed)
        stages[&#34;markData&#34;] = markResults
        if line is None:
            for (band, bandMarks) in sorted(markResults.items()):
                for ((seq, mark), entries) in sorted(bandMarks.items()):
                    indent(level=2)
                    kept = sum(1 for e in entries if e[0])
                    wiped = len(entries) - kept
                    warning(
                        f&#34;{seq:&gt;2} - {band:&lt;10}: {mark:&lt;20}&#34;
                        f&#34; wiped {wiped:&gt;4} x, kept {kept:&gt;4} x&#34;,
                        tm=False,
                    )
        else:
            self.show(stage=&#34;markData&#34;)
        indent(level=1)
        info(&#34;cleaning done&#34;)

    def _showCleanInfo(self):
        &#34;&#34;&#34;Pretty-prints the result of the cleaning stage.
        &#34;&#34;&#34;

        engine = self.engine
        C = engine.C
        grey = C.greyGRS
        tm = engine.tm
        info = tm.info
        indent = tm.indent
        stages = self.stages
        markData = stages.get(&#34;markData&#34;, {})
        total = 0

        total = 0
        for (band, markInfo) in sorted(markData.items()):
            indent(level=0)
            info(band, tm=False)
            for ((seq, mark), entries) in sorted(markInfo.items()):
                indent(level=1)
                wiped = sum(1 for e in entries if not e[0])
                total += wiped
                notWiped = len(entries) - wiped
                markImage = reborder(engine.marks[band][mark][&#34;gray&#34;], 2, grey)
                showImage(markImage)
                info(
                    f&#34;{seq:&gt;2}: {mark:&lt;20} wiped {wiped:&gt;4} x, kept {notWiped:&gt;4} x&#34;,
                    tm=False,
                )
                info(
                    f&#34;{&#39;&#39;:24} kept  {notWiped:&gt;4} x&#34;, tm=False,
                )
                for (
                    k,
                    value,
                    conn,
                    border,
                    stripe,
                    column,
                    top,
                    bottom,
                    left,
                    right,
                ) in sorted(entries):
                    indent(level=2)
                    wRep = &#34;kept&#34; if k else &#34;wiped&#34;
                    block = f&#34;{stripe}{column}&#34;
                    info(
                        f&#34;{wRep:&lt;5} [{block:&gt;3}]&#34;
                        f&#34; tblr={top:&gt;4} {bottom:&gt;4} {left:&gt;4} {right:&gt;4},&#34;
                        f&#34; value={value:5.2f} conn={conn:5.3f} border={border:&gt;2}&#34;,
                        tm=False,
                    )

    def _ocr(self):
        &#34;&#34;&#34;Calls the OCR engine for a page.
        &#34;&#34;&#34;

        stages = self.stages

        reader = OCR(self.engine, page=self)
        stages[&#34;ocrData&#34;] = reader.read()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pipeline.page.Page"><code class="flex name class">
<span>class <span class="ident">Page</span></span>
<span>(</span><span>engine, f, batch=False, boxed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>All processing steps for a single page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>engine</code></strong> :&ensp;<code>object</code></dt>
<dd>The <code><a title="pipeline.book.Book" href="book.html#pipeline.book.Book">Book</a></code> object</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>string</code></dt>
<dd>The file name of the scanned page with extension, without directory</dd>
<dt><strong><code>batch</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to run in batch mode.
In batch mode everything is geared to the final output.
Less intermediate results are computed and stored.
Less feedback happens on the console.</dd>
<dt><strong><code>boxed</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If in batch mode, produce also images that display the cleaned marks
in boxes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/150ca46e478e369dd6ab4edeb7f2ad2e9f841f57/pipeline/page.py#L31-L808" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Page:
    def __init__(self, engine, f, batch=False, boxed=True):
        &#34;&#34;&#34;All processing steps for a single page.

        Parameters
        ----------
        engine: object
            The `pipeline.book.Book` object
        f: string
            The file name of the scanned page with extension, without directory
        batch: boolean, optional `False`
            Whether to run in batch mode.
            In batch mode everything is geared to the final output.
            Less intermediate results are computed and stored.
            Less feedback happens on the console.
        boxed: boolean, optional `True`
            If in batch mode, produce also images that display the cleaned marks
            in boxes.
        &#34;&#34;&#34;

        self.engine = engine
        C = engine.C
        tm = engine.tm
        error = tm.error
        self.file = f
        (self.bare, self.ext) = splitext(f, withDot=False)
        self.empty = True
        self.batch = batch
        self.boxed = boxed
        self.stages = {}

        inDir = C.inDir
        path = f&#34;{inDir}/{f}&#34;
        if not batch and not os.path.exists(path):
            error(f&#34;Page file not found: {path}&#34;)
            return

        self.empty = False
        orig = cv2.imread(path)

        self.stages = {&#34;orig&#34;: orig}

    def show(self, stage=None, band=None, mark=None, **displayParams):
        &#34;&#34;&#34;Displays processing stages of an page.

        See `pipeline.parameters.STAGES`.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.
        band: string | iterable, optional `None`
            If no band is passed, no bands are indicated.
            Otherwise, the indicated bands are shown.
            If a string, it may be a comma-separated list of band names.
            Otherwise it is an iterable of band names.
        mark: string | iterable, optional `None`
            If `None` is passed, no marks are shown.
            If `&#34;&#34;` is passed, all marks on the selected bands are shown.
            Otherwise, the indicated mark boxes are shown, irrespective
            of their bands:
            If given as a string, it may be a comma-separated list of mark names.
            Otherwise it is an iterable of mark names.
            This information will be taken from the result of the `markData` stage.
        display: dict, optional
            A set of display parameters, such as `width`, `height`
            (anything accepted by `IPython.display.Image`).

        Notes
        -----
        The mark option works for the &#34;boxed&#34; stage:
        All marks not specified in the mark parameter will not be shown.

        But this option also works for all other image stages: the marks
        will be displayed on a fresh copy of that stage.

        When used for a grayscale stage, the color of the mark boxes is lost.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C

        stages = self.stages
        marks = engine.marks
        blocks = self.blocks

        for s in parseStages(stage, set(stages), C.stageOrder, error):
            stageData = stages[s]

            (stageType, stageExt) = C.stages[s]
            if stageType == &#34;data&#34;:
                self._serial(s, stageData, stageExt)
            else:
                img = stageData

                headingInfo = []

                if band is not None or mark is not None:
                    img = (
                        stages[&#34;demarginedC&#34;]
                        if s == &#34;boxed&#34; and mark is not None
                        else stageData
                    ).copy()
                    for ((stripe, column), data) in blocks.items():

                        bands = data[&#34;bands&#34;]
                        doBands = (
                            () if band is None else parseBands(band, set(bands), error)
                        )
                        doBandSet = set(doBands)
                        bandRep = f&#34; with bands {&#39;, &#39;.join(doBands)}&#34; if doBands else &#34;&#34;
                        doMarks = (
                            set()
                            if mark is None
                            else parseMarks(mark, marks, set(doBands), error)
                        )
                        markRep = (
                            f&#34; with marks {&#39;, &#39;.join(sorted(doMarks))}&#34;
                            if doMarks
                            else &#34;&#34;
                        )
                        headingInfo.append(f&#34;&lt;b&gt;{stripe}{column}&lt;/b&gt; {bandRep}{markRep}&#34;)

                        (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                        imBW = rightB - leftB
                        for band in doBands:
                            bandInfo = bands[band]
                            uppers = bandInfo[&#34;uppers&#34;]
                            lowers = bandInfo[&#34;lowers&#34;]
                            bColor = bandInfo[&#34;color&#34;]
                            for (upper, lower) in zip(uppers, lowers):
                                theUpper = topB + upper
                                theLower = topB + lower
                                theLeft = leftB + 10
                                theRight = leftB + imBW - 10
                                cv2.rectangle(
                                    img,
                                    (theLeft, theUpper),
                                    (theRight, theLower),
                                    bColor,
                                    2,
                                )
                                cv2.rectangle(
                                    img,
                                    (leftB, theUpper),
                                    (theLeft, theLower),
                                    bColor,
                                    -1,
                                )
                                cv2.rectangle(
                                    img,
                                    (theRight, theUpper),
                                    (leftB + imBW, theLower),
                                    bColor,
                                    -1,
                                )
                    markData = stages.get(&#34;markData&#34;, {})
                    markLegend = {}

                    for (band, bandMarks) in markData.items():
                        if doBands and band not in doBandSet:
                            continue
                        for ((seq, mrk), hits) in bandMarks.items():
                            if mrk not in doMarks:
                                continue
                            markKey = f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;
                            markValue = (band, mrk, len(hits))
                            markLegend[markKey] = markValue
                            for (
                                kept,
                                value,
                                connDegree,
                                connectBorder,
                                stripe,
                                column,
                                top,
                                bottom,
                                left,
                                right,
                            ) in hits:
                                addBox(
                                    C,
                                    img,
                                    top,
                                    bottom,
                                    left,
                                    right,
                                    kept,
                                    band,
                                    seq,
                                    connDegree,
                                )

                    if markLegend:
                        html = []
                        html.append(
                            &#34;&lt;details open&gt;&lt;summary&gt;Mark legend&lt;/summary&gt;&lt;table&gt;&#34;
                        )
                        html.append(
                            &#34;&lt;tr&gt;&lt;th&gt;acro&lt;/th&gt;&lt;th&gt;band&lt;/th&gt;&#34;
                            &#34;&lt;th&gt;mark&lt;/th&gt;&lt;th&gt;hits&lt;/th&gt;&lt;/tr&gt;&#34;
                        )
                        for (k, (b, m, n)) in sorted(markLegend.items()):
                            html.append(
                                f&#34;&lt;tr&gt;&lt;td&gt;{k}&lt;/td&gt;&lt;td&gt;{b}&lt;/td&gt;&#34;
                                f&#34;&lt;td&gt;{m}&lt;/td&gt;&lt;td&gt;{n}&lt;/td&gt;&lt;/tr&gt;&#34;
                            )
                        html.append(&#34;&lt;/table&gt;&lt;/details&gt;&#34;)
                        display(HTML(&#34;&#34;.join(html)))
                display(
                    HTML(f&#34;&lt;div&gt;{s} {&#39;;&#39;.join(headingInfo)}&lt;/div&gt;&#34;)
                )
                showImage(img, **displayParams)

    def write(self, stage=None):
        &#34;&#34;&#34;Writes processing stages of an page to disk.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.

        Returns
        -------
        None
            The stages are written into the `inter` subdirectory,
            with the name of the stage appended to the file name.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C
        interDir = C.interDir

        bare = self.bare
        ext = self.ext
        stages = self.stages

        for s in parseStages(stage, set(C.stages), C.stageOrder, error):
            if s not in stages:
                continue
            stageData = stages[s]
            (stageType, stageExt) = C.stages[s]
            path = f&#34;{interDir}/{bare}-{s}.{stageExt or ext}&#34;
            if stageType == &#34;data&#34;:
                with open(path, &#34;w&#34;) as f:
                    self._serial(s, stageData, stageExt, f)
            else:
                cv2.imwrite(path, stageData)

    def _serial(self, stage, data, extension, handle=None):
        &#34;&#34;&#34;serializes data in accordance with file type.

        Parameters
        ----------
        data:
            The data to serialize. The type of data must be compatible with
            the *extension*.
        extension: string
            The file type according to which the data must be serialized.
        handle: string, optional `None`
            If `None`, output is prepared for display in a Jupter notebook,
            else it is a file handle and the data is serialized
            in the canonical way and written to that file.

        Returns
        -------
        string
            The serialized data.
            If the extension does not match a recognized file type,
            the Python `repr` of the data is returned.

        Notes
        -----
        The following data type/extension combinations are supported:

        extension | data type
        --- | ---
        tsv | tuple/list of tuple/list
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        info = tm.info

        if handle:
            if stage == &#34;markData&#34;:
                data = storeCleanInfo(data)
            handle.write(
                &#34;&#34;.join(&#34;\t&#34;.join(str(column) for column in row) + &#34;\n&#34; for row in data)
                if extension == &#34;tsv&#34;
                else repr(data)
            )
        else:
            if stage == &#34;markData&#34;:
                self._showCleanInfo()
            else:
                info(data, tm=False)

    def _normalize(self):
        &#34;&#34;&#34;Normalizes a page.

        It produces a stage that is unskewed: *rotated* and blurred.
        The same rotation will be applied to the original scan,
        resulting in stage *normalized*.

        Unskewing is needed otherwise the footnote line will not be found.
        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        C = engine.C
        whit = C.whiteGRS

        batch = self.batch
        boxed = self.boxed
        stages = self.stages
        orig = stages[&#34;orig&#34;]

        removeSkewStripes(orig, C.skewBorder, C.whiteRGB)
        gray = cv2.cvtColor(orig, cv2.COLOR_BGR2GRAY)
        stages[&#34;gray&#34;] = gray

        blurred = cv2.GaussianBlur(gray, (C.blurX, C.blurY), 0, 0)

        (th, threshed) = cv2.threshold(
            blurred, 127, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )
        pts = cv2.findNonZero(threshed)
        ret = cv2.minAreaRect(pts)

        (cx, cy), (rw, rh), ang = ret
        if rw &gt; rh:
            rw, rh = rh, rw
            ang += 90

        M = cv2.getRotationMatrix2D((cx, cy), ang, 1.0)

        rotated = cv2.warpAffine(threshed, M, (threshed.shape[1], threshed.shape[0]))
        removeSkewStripes(rotated, C.skewBorder, C.blackRGB)
        normalized = cv2.warpAffine(gray, M, (gray.shape[1], gray.shape[0]))
        removeSkewStripes(normalized, C.skewBorder, whit)

        if not batch or boxed:
            normalizedC = cv2.warpAffine(orig, M, (orig.shape[1], orig.shape[0]))
            removeSkewStripes(normalizedC, C.skewBorder, C.whiteRGB)

        stages[&#34;rotated&#34;] = rotated
        stages[&#34;normalized&#34;] = normalized
        if not batch or boxed:
            stages[&#34;normalizedC&#34;] = normalizedC

    def _layout(self):
        &#34;&#34;&#34;Divide the page into stripes and the stripes into columns.

        We detect vertical strokes as columns separators and horizontal strokes
        as separators to split off top and bottom material.

        A page may or may not be partially divided into columns.
        Where there is a vertical stroke, we define a stripe: the
        horizontal band that contains the vertical stroke tightly and extends to
        the full with of the page.

        Between the stripes corresponding to column separators we have stripes that
        are not split into columns.

        The stripes will be numbered from top to bottom, starting at 1.

        If a stripe is not split, it defines a roi (region of interest) with
        label `(i, &#39;&#39;)`.

        If it is split, it defines blocks with labels `(i, &#39;r&#39;)` and `(i, &#39;l&#39;)`.

        Every horizontal stripe will be examined. W e have to determine whether
        it is a top separator or a bottom separator.
        As a rule of thumb: horizontal stripes in the top stripe are top-separators,
        all other horizontal stripes are bottom separators.

        If there are multiple horizontal strokes in a roi, the most aggressive
        one will be taken, i.e. the one that causes the most matarial to be discarded.

        All further operations will take place on these blocks (and not on the
        page as a whole).

        The result of this stage is, besides the blocks, an image of the page
        with the blocks marked and labelled.
        &#34;&#34;&#34;

        batch = self.batch
        boxed = self.boxed
        engine = self.engine
        C = engine.C
        tm = engine.tm
        indent = tm.indent
        info = tm.info

        stages = self.stages
        if not batch or boxed:
            layout = stages[&#34;normalizedC&#34;].copy()
            stages[&#34;layout&#34;] = layout

        indent(level=3)
        stretchesH = getStretches(C, info, stages, True, batch)
        stretchesV = getStretches(C, info, stages, False, batch)
        stripes = getStripes(stages, stretchesV)
        blocks = getBlocks(C, stages, stripes, batch)
        self.blocks = blocks
        applyHRules(C, stages, stretchesH, stripes, blocks, batch, boxed)
        emptyBlocks = getHistograms(C, stages, blocks, batch, boxed)
        if not batch:
            grayInterBlocks(C, stages, blocks, emptyBlocks)

    def _clean(self, mark=None, block=None, line=None, showKept=False):
        &#34;&#34;&#34;Remove marks from the page.

        The blocks of the page are cleaned of marks.

        New stages of the page are added:

        *   *clean* all targeted marks removed
        *   *cleanh* all targeted marks highlighted in light gray
        *   *boxed* all targeted marks boxed in light gray
        *   *markData* information about each detected mark.

        Parameters
        ----------
        mark: iterable of tuples (band, mark, [params]), optional `None`
            If `None`, all marks that are presented in the book
            directory are used.
            Otherwise, a series of marks is specified together with the band
            where this mark is searched in. Optionally you can also
            put parameters in the tuple: the accuracy, connectBorder and connectRatio.
        block: (integer, string), optional `None`
            Block identifier. If specified, only this block will be cleaned.
            If absent, cleans all blocks.
        line: integer, optional `None`
            Line number specifying the line numbers to clean.
            In all specified blocks, only the line with this number will be cleaned.
            If absent, cleans all lines in the specified blocks.
        showKept: boolean, optional `False`
            Whether to show the mark candidates that are kept.
            If False, kept marks do not show up as green boxes,
            and they do not contribute to the markData layer.
        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        tm = engine.tm
        indent = tm.indent
        info = tm.info
        error = tm.error
        warning = tm.warning
        C = engine.C

        marks = engine.marks
        batch = self.batch
        boxed = self.boxed

        markParams = C.markParams
        boxBorder = C.boxBorder

        connectBorder = C.connectBorder
        threshold = C.connectThreshold
        maxHits = C.maxHits
        color = dict(clean=C.cleanRGB, cleanh=C.cleanhRGB,)

        if mark is None:
            searchMarks = {subdir: markItems for (subdir, markItems) in marks.items()}
        else:
            searchMarks = {}
            for item in mark:
                (band, name) = item[0:2]
                if band not in marks or name not in marks[band]:
                    error(f&#34;No such mark: {band}/{mark}&#34;)
                    continue
                params = item[2] if len(item) &gt; 2 else {}
                for (acro, v) in params.items():
                    if acro not in markParams:
                        error(f&#34;Unknown parameter `{acro}` = `{v}`&#34;)
                configuredMark = marks[band][name]
                seq = configuredMark[&#34;seq&#34;]
                searchMarks.setdefault(band, {})[name] = dict(
                    seq=seq, gray=configuredMark[&#34;gray&#34;]
                )
                for (acro, full) in markParams.items():
                    searchMarks[band][name][full] = params.get(
                        acro, configuredMark[full]
                    )

        stages = self.stages
        demargined = stages.get(&#34;demargined&#34;, stages[&#34;gray&#34;])
        if batch:
            resultStages = (&#34;clean&#34;, &#34;boxed&#34;) if boxed else (&#34;clean&#34;,)
            if boxed:
                demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
        else:
            demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
            resultStages = (&#34;clean&#34;, &#34;cleanh&#34;, &#34;boxed&#34;)
        for stage in resultStages:
            stages[stage] = (demarginedC if stage == &#34;boxed&#34; else demargined).copy()

        tasks = [
            (
                stage,
                stages[stage],
                None if stage == &#34;boxed&#34; else color[stage],
                boxBorder if stage == &#34;boxed&#34; else -1,
            )
            for stage in resultStages
        ]

        foundHits = {}
        cleanClr = color[&#34;clean&#34;]
        blocks = self.blocks
        markResults = {}

        for ((stripe, column), data) in blocks.items():
            if block is not None and block != (stripe, column):
                continue
            (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
            thisDemargined = demargined[topB:bottomB, leftB:rightB]
            if not batch or boxed:
                thisBoxed = stages[&#34;boxed&#34;][topB:bottomB, leftB:rightB]
                theUpper = None
                theLower = None
                maxH = bottomB - topB

            for (band, markData) in searchMarks.items():
                if &#34;bands&#34; not in data:
                    # error(f&#34;No bands in {stripe}{column}&#34;)
                    continue
                bandData = data[&#34;bands&#34;][band]
                uppers = bandData[&#34;uppers&#34;]
                lowers = bandData[&#34;lowers&#34;]

                for (markName, markInfo) in markData.items():
                    foundHits.setdefault(band, {})[markName] = 0
                    seq = markInfo[&#34;seq&#34;]
                    mark = markInfo[&#34;gray&#34;]
                    connectBorder = markInfo[&#34;connectBorder&#34;]
                    accuracy = markInfo[&#34;accuracy&#34;]
                    ratio = markInfo[&#34;connectRatio&#34;]
                    (markH, markW) = mark.shape[:2]

                    nPts = 0
                    clusters = []
                    for (i, (upper, lower)) in enumerate(zip(uppers, lowers)):
                        if line is not None:
                            if i &lt; line - 1:
                                continue
                            elif i &gt; line - 1:
                                break
                        if line is not None and i == line - 1:
                            if theUpper is None or theUpper &gt; upper:
                                theUpper = upper
                            if theLower is None or theLower &lt; lower:
                                theLower = lower

                        roi = thisDemargined[
                            upper : lower + 1,
                        ]
                        (roih, roiw) = roi.shape[:2]
                        if roih &lt; markH or roiw &lt; markW:
                            # search template exceeds roi image
                            continue
                        result = cv2.matchTemplate(roi, mark, cv2.TM_CCOEFF_NORMED)
                        loc = np.where(result &gt;= accuracy)
                        pts = list(zip(*loc))
                        if len(pts) &gt; maxHits:
                            error(
                                f&#34;mark &#39;{band}:{markName}&#39;:&#34;
                                f&#34; too many hits: {len(pts)} &gt; {maxHits}&#34;
                            )
                            warning(&#34;Increase accuracy for this template&#34;)
                            continue
                        if not pts:
                            continue

                        nPts += len(pts)
                        clusters = cluster(pts, result)

                        for (pt, value) in clusters:
                            connDegree = connected(
                                markH, markW, connectBorder, threshold, roi, pt
                            )
                            pt = (pt[0] + upper + topB, pt[1] + leftB)
                            (top, bottom, left, right) = (
                                pt[0],
                                pt[0] + markH,
                                pt[1],
                                pt[1] + markW,
                            )
                            if connDegree &gt; ratio:
                                if showKept and (not batch or boxed):
                                    im = stages[&#34;boxed&#34;]
                                    addBox(
                                        C,
                                        im,
                                        top,
                                        bottom,
                                        left,
                                        right,
                                        True,
                                        band,
                                        seq,
                                        connDegree,
                                    )
                                    markResults.setdefault(band, {}).setdefault(
                                        (seq, markName), []
                                    ).append(
                                        (
                                            True,
                                            value,
                                            connDegree,
                                            connectBorder,
                                            stripe,
                                            column,
                                            top,
                                            bottom,
                                            left,
                                            right,
                                        )
                                    )
                            else:
                                if batch and not boxed:
                                    cv2.rectangle(
                                        stages[&#34;clean&#34;],
                                        (left, top),
                                        (right, bottom),
                                        cleanClr,
                                        -1,
                                    )
                                else:
                                    for (stage, im, clr, brd) in tasks:
                                        isBoxed = stage == &#34;boxed&#34;
                                        if isBoxed:
                                            addBox(
                                                C,
                                                im,
                                                top,
                                                bottom,
                                                left,
                                                right,
                                                False,
                                                band,
                                                seq,
                                                connDegree,
                                            )
                                            markResults.setdefault(band, {}).setdefault(
                                                (seq, markName), []
                                            ).append(
                                                (
                                                    False,
                                                    value,
                                                    connDegree,
                                                    connectBorder,
                                                    stripe,
                                                    column,
                                                    top,
                                                    bottom,
                                                    left,
                                                    right,
                                                )
                                            )
                                        else:
                                            cv2.rectangle(
                                                im,
                                                (left, top),
                                                (right, bottom),
                                                clr,
                                                -1,
                                            )

            if not batch or boxed:
                if line is not None and theUpper is not None and theLower is not None:
                    grace = 20
                    thisTop = max(0, theUpper - grace)
                    thisBottom = min(maxH, theLower + grace)
                    info(
                        f&#34;block {stripe}{column} line {line} BEFORE/AFTER cleaning\n&#34;,
                        tm=False,
                    )
                    roi = thisDemargined[thisTop:thisBottom]
                    showImage(roi)
                    roiBoxed = thisBoxed[thisTop:thisBottom]
                    showImage(roiBoxed)
        stages[&#34;markData&#34;] = markResults
        if line is None:
            for (band, bandMarks) in sorted(markResults.items()):
                for ((seq, mark), entries) in sorted(bandMarks.items()):
                    indent(level=2)
                    kept = sum(1 for e in entries if e[0])
                    wiped = len(entries) - kept
                    warning(
                        f&#34;{seq:&gt;2} - {band:&lt;10}: {mark:&lt;20}&#34;
                        f&#34; wiped {wiped:&gt;4} x, kept {kept:&gt;4} x&#34;,
                        tm=False,
                    )
        else:
            self.show(stage=&#34;markData&#34;)
        indent(level=1)
        info(&#34;cleaning done&#34;)

    def _showCleanInfo(self):
        &#34;&#34;&#34;Pretty-prints the result of the cleaning stage.
        &#34;&#34;&#34;

        engine = self.engine
        C = engine.C
        grey = C.greyGRS
        tm = engine.tm
        info = tm.info
        indent = tm.indent
        stages = self.stages
        markData = stages.get(&#34;markData&#34;, {})
        total = 0

        total = 0
        for (band, markInfo) in sorted(markData.items()):
            indent(level=0)
            info(band, tm=False)
            for ((seq, mark), entries) in sorted(markInfo.items()):
                indent(level=1)
                wiped = sum(1 for e in entries if not e[0])
                total += wiped
                notWiped = len(entries) - wiped
                markImage = reborder(engine.marks[band][mark][&#34;gray&#34;], 2, grey)
                showImage(markImage)
                info(
                    f&#34;{seq:&gt;2}: {mark:&lt;20} wiped {wiped:&gt;4} x, kept {notWiped:&gt;4} x&#34;,
                    tm=False,
                )
                info(
                    f&#34;{&#39;&#39;:24} kept  {notWiped:&gt;4} x&#34;, tm=False,
                )
                for (
                    k,
                    value,
                    conn,
                    border,
                    stripe,
                    column,
                    top,
                    bottom,
                    left,
                    right,
                ) in sorted(entries):
                    indent(level=2)
                    wRep = &#34;kept&#34; if k else &#34;wiped&#34;
                    block = f&#34;{stripe}{column}&#34;
                    info(
                        f&#34;{wRep:&lt;5} [{block:&gt;3}]&#34;
                        f&#34; tblr={top:&gt;4} {bottom:&gt;4} {left:&gt;4} {right:&gt;4},&#34;
                        f&#34; value={value:5.2f} conn={conn:5.3f} border={border:&gt;2}&#34;,
                        tm=False,
                    )

    def _ocr(self):
        &#34;&#34;&#34;Calls the OCR engine for a page.
        &#34;&#34;&#34;

        stages = self.stages

        reader = OCR(self.engine, page=self)
        stages[&#34;ocrData&#34;] = reader.read()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pipeline.page.Page.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, stage=None, band=None, mark=None, **displayParams)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays processing stages of an page.</p>
<p>See <code><a title="pipeline.parameters.STAGES" href="parameters.html#pipeline.parameters.STAGES">STAGES</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If no stage is passed, all stages are shown as thumbnails.
Otherwise, the indicated stages are shown.
If a string, it may be a comma-separated list of stage names.
Otherwise it is an iterable of stage names.</dd>
<dt><strong><code>band</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If no band is passed, no bands are indicated.
Otherwise, the indicated bands are shown.
If a string, it may be a comma-separated list of band names.
Otherwise it is an iterable of band names.</dd>
<dt><strong><code>mark</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If <code>None</code> is passed, no marks are shown.
If <code>""</code> is passed, all marks on the selected bands are shown.
Otherwise, the indicated mark boxes are shown, irrespective
of their bands:
If given as a string, it may be a comma-separated list of mark names.
Otherwise it is an iterable of mark names.
This information will be taken from the result of the <code>markData</code> stage.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A set of display parameters, such as <code>width</code>, <code>height</code>
(anything accepted by <code>IPython.display.Image</code>).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The mark option works for the "boxed" stage:
All marks not specified in the mark parameter will not be shown.</p>
<p>But this option also works for all other image stages: the marks
will be displayed on a fresh copy of that stage.</p>
<p>When used for a grayscale stage, the color of the mark boxes is lost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/150ca46e478e369dd6ab4edeb7f2ad2e9f841f57/pipeline/page.py#L73-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(self, stage=None, band=None, mark=None, **displayParams):
    &#34;&#34;&#34;Displays processing stages of an page.

    See `pipeline.parameters.STAGES`.

    Parameters
    ----------
    stage: string | iterable, optional `None`
        If no stage is passed, all stages are shown as thumbnails.
        Otherwise, the indicated stages are shown.
        If a string, it may be a comma-separated list of stage names.
        Otherwise it is an iterable of stage names.
    band: string | iterable, optional `None`
        If no band is passed, no bands are indicated.
        Otherwise, the indicated bands are shown.
        If a string, it may be a comma-separated list of band names.
        Otherwise it is an iterable of band names.
    mark: string | iterable, optional `None`
        If `None` is passed, no marks are shown.
        If `&#34;&#34;` is passed, all marks on the selected bands are shown.
        Otherwise, the indicated mark boxes are shown, irrespective
        of their bands:
        If given as a string, it may be a comma-separated list of mark names.
        Otherwise it is an iterable of mark names.
        This information will be taken from the result of the `markData` stage.
    display: dict, optional
        A set of display parameters, such as `width`, `height`
        (anything accepted by `IPython.display.Image`).

    Notes
    -----
    The mark option works for the &#34;boxed&#34; stage:
    All marks not specified in the mark parameter will not be shown.

    But this option also works for all other image stages: the marks
    will be displayed on a fresh copy of that stage.

    When used for a grayscale stage, the color of the mark boxes is lost.
    &#34;&#34;&#34;

    engine = self.engine
    tm = engine.tm
    error = tm.error
    C = engine.C

    stages = self.stages
    marks = engine.marks
    blocks = self.blocks

    for s in parseStages(stage, set(stages), C.stageOrder, error):
        stageData = stages[s]

        (stageType, stageExt) = C.stages[s]
        if stageType == &#34;data&#34;:
            self._serial(s, stageData, stageExt)
        else:
            img = stageData

            headingInfo = []

            if band is not None or mark is not None:
                img = (
                    stages[&#34;demarginedC&#34;]
                    if s == &#34;boxed&#34; and mark is not None
                    else stageData
                ).copy()
                for ((stripe, column), data) in blocks.items():

                    bands = data[&#34;bands&#34;]
                    doBands = (
                        () if band is None else parseBands(band, set(bands), error)
                    )
                    doBandSet = set(doBands)
                    bandRep = f&#34; with bands {&#39;, &#39;.join(doBands)}&#34; if doBands else &#34;&#34;
                    doMarks = (
                        set()
                        if mark is None
                        else parseMarks(mark, marks, set(doBands), error)
                    )
                    markRep = (
                        f&#34; with marks {&#39;, &#39;.join(sorted(doMarks))}&#34;
                        if doMarks
                        else &#34;&#34;
                    )
                    headingInfo.append(f&#34;&lt;b&gt;{stripe}{column}&lt;/b&gt; {bandRep}{markRep}&#34;)

                    (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                    imBW = rightB - leftB
                    for band in doBands:
                        bandInfo = bands[band]
                        uppers = bandInfo[&#34;uppers&#34;]
                        lowers = bandInfo[&#34;lowers&#34;]
                        bColor = bandInfo[&#34;color&#34;]
                        for (upper, lower) in zip(uppers, lowers):
                            theUpper = topB + upper
                            theLower = topB + lower
                            theLeft = leftB + 10
                            theRight = leftB + imBW - 10
                            cv2.rectangle(
                                img,
                                (theLeft, theUpper),
                                (theRight, theLower),
                                bColor,
                                2,
                            )
                            cv2.rectangle(
                                img,
                                (leftB, theUpper),
                                (theLeft, theLower),
                                bColor,
                                -1,
                            )
                            cv2.rectangle(
                                img,
                                (theRight, theUpper),
                                (leftB + imBW, theLower),
                                bColor,
                                -1,
                            )
                markData = stages.get(&#34;markData&#34;, {})
                markLegend = {}

                for (band, bandMarks) in markData.items():
                    if doBands and band not in doBandSet:
                        continue
                    for ((seq, mrk), hits) in bandMarks.items():
                        if mrk not in doMarks:
                            continue
                        markKey = f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;
                        markValue = (band, mrk, len(hits))
                        markLegend[markKey] = markValue
                        for (
                            kept,
                            value,
                            connDegree,
                            connectBorder,
                            stripe,
                            column,
                            top,
                            bottom,
                            left,
                            right,
                        ) in hits:
                            addBox(
                                C,
                                img,
                                top,
                                bottom,
                                left,
                                right,
                                kept,
                                band,
                                seq,
                                connDegree,
                            )

                if markLegend:
                    html = []
                    html.append(
                        &#34;&lt;details open&gt;&lt;summary&gt;Mark legend&lt;/summary&gt;&lt;table&gt;&#34;
                    )
                    html.append(
                        &#34;&lt;tr&gt;&lt;th&gt;acro&lt;/th&gt;&lt;th&gt;band&lt;/th&gt;&#34;
                        &#34;&lt;th&gt;mark&lt;/th&gt;&lt;th&gt;hits&lt;/th&gt;&lt;/tr&gt;&#34;
                    )
                    for (k, (b, m, n)) in sorted(markLegend.items()):
                        html.append(
                            f&#34;&lt;tr&gt;&lt;td&gt;{k}&lt;/td&gt;&lt;td&gt;{b}&lt;/td&gt;&#34;
                            f&#34;&lt;td&gt;{m}&lt;/td&gt;&lt;td&gt;{n}&lt;/td&gt;&lt;/tr&gt;&#34;
                        )
                    html.append(&#34;&lt;/table&gt;&lt;/details&gt;&#34;)
                    display(HTML(&#34;&#34;.join(html)))
            display(
                HTML(f&#34;&lt;div&gt;{s} {&#39;;&#39;.join(headingInfo)}&lt;/div&gt;&#34;)
            )
            showImage(img, **displayParams)</code></pre>
</details>
</dd>
<dt id="pipeline.page.Page.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, stage=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes processing stages of an page to disk.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If no stage is passed, all stages are shown as thumbnails.
Otherwise, the indicated stages are shown.
If a string, it may be a comma-separated list of stage names.
Otherwise it is an iterable of stage names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The stages are written into the <code>inter</code> subdirectory,
with the name of the stage appended to the file name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/150ca46e478e369dd6ab4edeb7f2ad2e9f841f57/pipeline/page.py#L250-L288" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write(self, stage=None):
    &#34;&#34;&#34;Writes processing stages of an page to disk.

    Parameters
    ----------
    stage: string | iterable, optional `None`
        If no stage is passed, all stages are shown as thumbnails.
        Otherwise, the indicated stages are shown.
        If a string, it may be a comma-separated list of stage names.
        Otherwise it is an iterable of stage names.

    Returns
    -------
    None
        The stages are written into the `inter` subdirectory,
        with the name of the stage appended to the file name.
    &#34;&#34;&#34;

    engine = self.engine
    tm = engine.tm
    error = tm.error
    C = engine.C
    interDir = C.interDir

    bare = self.bare
    ext = self.ext
    stages = self.stages

    for s in parseStages(stage, set(C.stages), C.stageOrder, error):
        if s not in stages:
            continue
        stageData = stages[s]
        (stageType, stageExt) = C.stages[s]
        path = f&#34;{interDir}/{bare}-{s}.{stageExt or ext}&#34;
        if stageType == &#34;data&#34;:
            with open(path, &#34;w&#34;) as f:
                self._serial(s, stageData, stageExt, f)
        else:
            cv2.imwrite(path, stageData)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/among" title="among Digital Manuscripts on GitHub"><img src="/fusus/images/fusus-small.png"></a></p>
<p><a href="/fusus/index.html">fusus home</a> - <a href="/fusus/cheatsheet.html">cheat sheet</a></p>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/annotation site:annotation.github.io site:www.annotation.nl"
data-gaCategoryParameter="pipeline.page">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pipeline" href="index.html">pipeline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pipeline.page.Page" href="#pipeline.page.Page">Page</a></code></h4>
<ul class="">
<li><code><a title="pipeline.page.Page.show" href="#pipeline.page.Page.show">show</a></code></li>
<li><code><a title="pipeline.page.Page.write" href="#pipeline.page.Page.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://digitalorientalist.com/about-cornelis-van-lit/">Cornelis van Lit</a>
<a href="https://www.annotation.nl">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="/text-fabric/images/DANS-logo.png" width=200></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>